/ *! jQuery v3.4.1 | (c) Фонд JS и другие участники | jquery.org/license * /
! function (e, t) {"использовать строгий"; "объект" == typeof module && "object" == typeof module.exports? module.exports = e.document? t (e,! 0): function (e) {if (! e.document) выбросить новую ошибку («jQuery требует окно с документом»); return t (e)}: t (e)} («undefined»! = typeof window? window: this, function ( C, e) {"использовать строгий"; var t = [], E = C.document, r = Object.getPrototypeOf, s = t.slice, g = t.concat, u = t.push, i = t. IndexOf, п = {}, о = n.toString, v = n.hasOwnProperty, а = v.toString, л = a.call (объект), у =}, т = функция (е) { "функция" {возвращение == typeof e && "number"! = typeof e.nodeType}, x = function (e) {вернуть ноль! = e && e === e.window}, c = {type:! 0, src:! 0, nonce: ! 0, noModule:! 0}; функция b (e, t, n) {var r, i, o = (n = n || E) .createElement ("script"); if (o.text = e, t) для (r в c) (i = t [r] || t.getAttribute && t.getAttribute (r)) && o.setAttribute (r, i); n.head.appendChild (o) .parentNode.removeChild (o)} функция w (e) {return null == e? e + "": "object" = = typeof e || "function" == typeof e? n [o.call (e)] || "object": typeof e} var f = "3.4.1", k = function (e, t) {return новый k.fn.init (e, t)}, p = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; функция d (e) {var t =! ! e && "длина" в e && e.length, n = w (e); вернуть! m (e) &&! x (e) && ("массив" === n || 0 === t || "число") == typeof t && 0 <t && t-1 в e)} k.fn = k.prototype = {jquery: f, конструктор: k, длина: 0, toArray: function () {вернуть s.call (this)}, получить: function (e) {return null == e? s.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = k.merge (this.constructor (), e); return t.prevObject = this, t}, каждый: function (e) {return k.each (this, e)}, map:function (n) {return this.pushStack (k.map (this, function (e, t) {return n.call (e, t, e)}))}, slice: function () {return this.pushStack ( s.apply (this, arguments))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (e) {var t = this.length, n = + e + (e <0? t: 0); вернуть this.pushStack (0 <= n && n <t? [this [n]]: [])}, end: function () { вернуть this.prevObject || this.constructor ()}, push: u, sort: t.sort, splice: t.splice}, k.extend = k.fn.extend = function () {var e, t, n , r, i, o, a = arguments [0] || {}, s = 1, u = arguments.length, l =! 1; for ("логическое" == typeof a && (l = a, a = arguments) [s] || {}, s ++), "объект" == typeof a || m (a) || (a = {}), s === u && (a = this, s -); s < u; s ++) if (null! = (e = arguments [s])) для (t in e) r = e [t], "__proto__"! == t && a! == r && (l && r && (k.isPlainObject (r) ) || (я = Array.isArray (г))) (п = а [т], о = я &&!Array.isArray (n)? []: I || k.isPlainObject (n)? N: {}, i =! 1, a [t] = k.extend (l, o, r)): void 0! == r && (a [t] = r)); вернуть a}, k.extend ({expando: "jQuery" + (f + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, error: function (e) {throw new Error (e)}, noop: function () {}, isPlainObject: function (e) {var t, n; return! (! e || "[object Объект] "! == o.call (е)) && (! (т = г (е)) ||" функции "== TypeOf (п = v.call (т," конструктор ") && t.constructor) && .call (n) === l)}, isEmptyObject: function (e) {var t; for (t in e) return! 1; return! 0}, globalEval: function (e, t) {b (e, {nonce: t && t.nonce})}, каждый: function (e, t) {var n, r = 0; if (d (e)) {for (n = e.length; r <n; r ++) if ( ! 1 === t.call (e [r], r, e [r])) break} else для (r в e) if (! 1 === t.call (e [r], r, e [r])) break; return e}, trim: function (e) {return null == e? "" :( e + ""). replace (p, "")},makeArray: function (e, t) {var n = t || []; вернуть null! = e && (d (Object (e))? k.merge (n, "string" == typeof e? [e]: e): u.call (n, e)), n}, inArray: function (e, t, n) {return null == t? -1: i.call (t, e, n)}, объединить: function (e, t) {for (var n = + t.length, r = 0, i = e.length; r <n; r ++) e [i ++] = t [r]; возвращаем e.length = i, e}, grep: function (e, t, n) {for (var r = [], i = 0, o = e.length, a =! n; i <o; i ++)! t (e [i] , i)! == a && r.push (e [i]); return r}, map: function (e, t, n) {var r, i, o = 0, a = []; if (d (e) )) для (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && a.push (i); еще для (o in e) null! = (i = t (e [o], o, n)) && a.push (i); вернуть g.apply ([], a)}, guid: 1, support: y}), "function" == typeof Symbol && (k.fn [Symbol.iterator] = t [Symbol.iterator]), k.each ("Булево число Строка Функция Массив Дата Символ объекта RegExp Ошибка" .split (""), function (e, t) { n ["[объект" + t + "] "] = t.toLowerCase ()}); var h = function (n) {var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E , v, s, c, y, k = "sizzle" + 1 * новая дата, m = n.document, S = 0, r = 0, p = ue (), x = ue (), N = ue ( ), A = ue (), D = function (e, t) {return e === t && (l =! 0), 0}, j = {}. HasOwnProperty, t = [], q = t.pop , L = t.push, H = t.push, O = t.slice, P = function (e, t) {для (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) return n; return-1}, R = "проверено | выбрано | асинхронно | автофокус | автозапуск | элементы управления | отложить | отключено | отключено | скрыто | ismap | цикл | несколько | открыто | доступно только для чтения | требуется | ограничено» ?. "М = "[\\ x20 \\ т \\ г \\ п \\ е]", I =" (: \\\\ | [\\ w-] | [^ \ 0 - \\ xa0]) + "W = "\\ [" + M + "* (" + I + ") (?:" + M + "* ([* ^ $ |! ~] =?)" + M +" * (? : '((?:. \\\\ | [^ \\\\']) *) '| \ "((?:. \\\\ | [^ \\\\\"]) *) \ "| (" + I + ")) |)" + M + "* \\]", $ = ":(" + I + ") (: \\ ((( '((?:?. \\\\ | [^ \\\\ ']) *)'| \ "((?:. \\\\ | [^ \\\\\"]) *) \ ") | ((?:. \\\\ | [^ \\\\ () [\\ ]] | "+ W +") *) |. *) \\) |) ", F = новый RegExp (M +" + "," g "), B = новый RegExp (" ^ "+ M +" + | ( (?: ^ | [^ \\\\]) (?: \\\\.) *) "+ M +" + $ "," g "), _ = new RegExp (" ^ "+ M +" *, "+ M +" * "), z = новый RegExp (" ^ "+ M +" * ([> + ~] | "+ M +") "+ M +" * "), U = новый RegExp (M +" |> " ), X = новый RegExp ($), V = новый RegExp ("^" + I + "$"), G = {ID: новый RegExp ("^ # (" + I + ")"), КЛАСС: новый RegExp ( "^ \\. (" + I + ")"), TAG: новый RegExp ("^ (" + I + "| [*])"), ATTR: новый RegExp ("^" + W), PSEUDO: новый RegExp ("^" + $), РЕБЕНОК: новый RegExp ("^ :( только | первый | последний | последний | nth | последний-последний) - (потомок | типа) (?: \\ (" + M + "* (даже | нечетные | (([+ -] |) (\\ д *) п |) "+ M +" * (?:([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: new RegExp (" ^ (?: "+ R + ") $", "i"), needsContext: new RegExp ("^" + M + "* [> + ~] |: (четный | нечетный | eq | gt | lt | nth | первый | последний) (?: \ \ (?? "+ M +" * ((: - \\ d) \\ d *) "+ M +" * \\) |) (= [^ -] | $)», "я")}, Y = / html $ / I, Q = / ^ (?: вход | выбрать | текстовое поле | кнопка) $ / I, J = / ^ ч \ д $ / I, K = / ^ [^ {] + \ {\ s * \ [native \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ee = / [+ ~] /, te = new RegExp ("\\\\ ([\\ da-f] {1,6}" + M + "? | (" + M + ") |.)", "ig"), ne = function (e, t, n) {var r = "0x" + t-65536; return r! = r || n? t: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & г | 56320)}, п = / ([\ 0- \ x1f \ x7f] | ^ - \ г) |? ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, т.е. = function (e, t) {return t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\ "+ e.charCodeAt (e.length-1) .toString (16) +" ":" \\ "+ e}, oe = function () {T ()}, ae = be (function (e) {вернуться 0 === e.disabled && "Fieldset" === e.nodeName.toLowerCase (!)}, {реж: "ParentNode", следующий: "легенда"}); попробуйте {H.apply (т = O. вызов (m.childNodes), m.childNodes), т [m.childNodes.length] .nodeType} поймать (е) {Н = {применяются: t.length функция (е, т) {L.apply (е, O.call (t))}: функция (e, t) {var n = e.length, r = 0; while (e [n ++] = t [r ++]); e.length = n-1}}} функция se (t, e, n, r) {var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e? e.nodeType: 9; if (n = n || [], "string"! = typeof t ||! t || 1! == p && 9! == p && 11! == p) вернуть n; if (! r && ((e? e.ownerDocument || e: m) ! == С && Т (е), е = е || С, е)) {если (11! == р && (и = Z.exec (т))), если (я = и [1]) {если (9 === p) {if (! (a = e.getElementById (i))) вернуть n; if (a.id === i) вернуть n.push (a), n} еще if (f && (a =) е.getElementById (i)) && y (e, a) && a.id === i) вернуть n.push (a), n} else {if (u [2]) вернуть H.apply (n, e.getElementsByTagName (t) )), n; if ((i = u [3]) && d.getElementsByClassName && e.getElementsByClassName) возвращает H.apply (n, e.getElementsByClassName (i)), n} if (d.qsa &&! A [t + ""] && (! v ||! v.test (т)) && (1! == р || "объект"! == e.nodeName.toLowerCase ())) {если (с = т, е = е, 1 === р && U.test (т)) {(s = e.getAttribute ( "ID")) с = s.replace (п, т): e.setAttribute ( "идентификатор", с = к), о = (l = h (t)). length; while (o -) l [o] = "#" + s + "" + xe (l [o]); c = l.join (","), f = ee.test (t) && ye (e.parentNode) || e} try {return H.apply (n, f.querySelectorAll (c)), n} catch (e) {A (t,! 0)} окончательно {s === k && e.removeAttribute ("id")}}} return g (t.replace (B, "$ 1"), e, n, r)} function ue () {var r = [];return function e (t, n) {return r.push (t + "")> b.cacheLength && delete e [r.shift ()], e [t + ""] = n}} функция le (e) {return e [ k] =! 0, e} функция ce (e) {var t = C.createElement ("fieldset"); try {return !! e (t)} catch (e) {return! 1} finally {t.parentNode && t .parentNode.removeChild (t), t = null}} функция fe (e, t) {var n = e.split ("|"), r = n.length; while (r -) b.attrHandle [n [r]] = t} функция pe (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) возвращает r; if (n) while (n = n.nextSibling) if (n === t) return-1; return e? 1: -1} function de (t) {return function (e) {return «input» === e.nodeName.toLowerCase () && e.type === t}} функция he (n) {return function (e) {var t = e.nodeName.toLowerCase (); return ("input" === t || "кнопка" === т) && е.type === n}} function ge (t) {return function (e) {return «form» в e? e.parentNode &&! 1 === e.disabled? «label» в e? «label» в e. ParentNode e.parentNode.disabled === т: e.disabled === т: e.isDisabled === т || e.isDisabled == т && п (е) === т:! e.disabled == = t: «метка» в e && e.disabled === t}} функция ve (a) {return le (function (o) {return o = + o, le (function (e, t) {var n, r =) а ([], e.length, о), я = r.length;!, а (я -) е [п = г [г]] && (е [п] = (т [п] = е [п ]))})})} функция ye (e) {вернуть e && "undefined"! = typeof e.getElementsByTagName && e} для (e in d = se.support = {}, i = se.isXML = function (e) { var t = e.namespaceURI, n = (e.ownerDocument || e) .documentElement; вернуть! Y.test (t || n && n.nodeName || "HTML")}, T = se.setDocument = function (e) {var t, n, r = e? e.ownerDocument || e: m; return r! == C && 9 === r.nodeType && r.documentElement && (а = (С = г) .documentElement, Е =! I (C), м! == С && (п = C.defaultView) && n.top! == п && (n.addEventListener? n.addEventListener ( "разгржает ", oe,! 1): n.attachEvent && n.attachEvent (" onunload ", oe)), d.attributes = ce (function (e) {return e.className =" i ",! e.getAttribute (" className ") )}), d.getElementsByTagName = ce (function (e) {return e.appendChild (C.createComment ("")) ,! e.getElementsByTagName ("*"). length}), d.getElementsByClassName = K.test (C.getElementsByClassName), d.getById = ce (function (e) {вернуть a.appendChild (e) .id = k,! C.getElementsByName ||! C.getElementsByName (k) .length}), d.getById ? (b.filter.ID = function (e) {var t = e.replace (te, ne); return function (e) {return e.getAttribute ("id") === t}}, b.find .ID = function (e, t) {if ("undefined"! = Typeof t.getElementById &&E) {var n = t.getElementById (e); return n? [N]: []}}) :( b.filter.ID = function (e) {var n = e.replace (te, ne); return function (e) {var t = "undefined"! = typeof e.getAttributeNode && e.getAttributeNode ("id"); return t && t.value === n}}, b.find.ID = function (e, t) { if ("undefined"! = typeof t.getElementById && E) {var n, r, i, o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n. значение === е) возвращение [о]; я = t.getElementsByName (е), г = 0, в то время (о = я [г ++]), если ((п = o.getAttributeNode ( "ID")) && n.value === e) return [o]} return []}}), b.find.TAG = d.getElementsByTagName? function (e, t) {return "undefined"! = typeof t.getElementsByTagName? t.getElementsByTagName (e ): d.qsa? t.querySelectorAll (e): void 0}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*") === е) {в то время как (п = о [я ++]) 1 === n.nodeType &&r.push (n); return r} return o}, b.find.CLASS = d.getElementsByClassName && function (e, t) {if ("undefined"! = typeof t.getElementsByClassName && E) return t.getElementsByClassName (e)}, s = [], v = [], (d.qsa = K.test (C.querySelectorAll)) && (ce (function (e) {a.appendChild (e) .innerHTML = "<a id = '" + k + "'> </a> <select id ='" + k + "- \ r \\ 'msallowcapture =' '>> option selected =' '> </ option> </ select>", e.querySelectorAll (" [msallowcapture ^ = ''] ") длина && v.push. (" [* ^ $] = "+ M +" * (?: '' | \ "\") "), e.querySelectorAll (" [выбран] ") .length || v.push ( "\\ [" + M + "* (?: значение |" + R + ")"), e.querySelectorAll ( "[ID = ~" + к + "-]") длина. | | v.push ( "~ ="), д.querySelectorAll ( ": проверено") длина || v.push. ( ": проверено"), e.querySelectorAll ( "а #" + к + "+ *") длина || v.push (»# + [+... ~] ")}), ce (function (e) {e.innerHTML =" <a href='' disabled='disabled'> </a> <select disabled = 'disabled'> <option /> </ select > "; var t = C.createElement (" input "); t.setAttribute (" type "," hidden "), e.appendChild (t) .setAttribute (" name "," D "), e.querySelectorAll ( "[имя = d]") длина && v.push ( "имя" + M + "* [* ^ $ | ~] =?"), 2 == e.querySelectorAll (.!. ": включено") длина && v.push ( ": включено", ": отключено"), a.appendChild (е) .disabled = 0,2 == e.querySelectorAll ( ": отключено")! длина && v.push (. ": включено", ": отключено «),e.querySelectorAll ( "* ,: х"), v.push ( "*:.")})), (d.matchesSelector = K.test (с = a.matches || a.webkitMatchesSelector || а. mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && с (функция (е) {d.disconnectedMatch = c.call (е, "*"), c.call (е, "[s = '']: x "), s.push ("! = ", $)}), v = v.length && new RegExp (v.join (" | ")), s = s.length && new RegExp (s.join (" | ") ), t = K.test (a.compareDocumentPosition), y = t || K.test (a.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; вернуть e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r )))}:!? функция (е, т) {если (т), а (т = t.parentNode), если (т === е) возвращают 0; 1} вернуться, D = т функция (е, т ) {if (e === t) return l =! 0,0; var n =! e.compareDocumentPosition-! t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! d.sortDetached && t.compareDocumentPosition (e ) === п е === С || e.ownerDocument === м && у (т, е) - 1:?? Т === C === || t.ownerDocument м && у (м, т) 1 : u? P (u, e) -P (u, t): 0: 4 & n? -1: 1)}: функция (e, t) {if (e === t) return l =! 0,0 ; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; если (! i ||! o) вернуть e === C? -1 : t === C? 1: i? -1: o? 1: u? P (u, e) -P (u, t): 0; если (i === o) вернуть pe (e, t ), п = е; при этом (п = n.parentNode) a.unshift (п); п = т, в то время как (п = n.parentNode) s.unshift (п), в то время (а [R] === сек [r]) r ++; вернуть r? pe (a [r], s [r]): a [r] === m? -1: s [r] === m? 1: 0}), C }, se.matches = function (e, t) {return se (e, null, null, t)}, se.matchesSelector = function (e, t) {if ((e.ownerDocument || e)! == C && T (e), d.matchesSelector && E &&! A [t + ""] && (! S ||! S.test (t)) && (! V ||! V.test (t))) try {var n = c.call (e, t); if (n || d.disconnectedMatch || e.document && 11! == e.document.nodeType) return n} catch (e) { A (t,! 0)} return 0 <se (t, C, null, [e]). Length}, se.contains = function (e, t) {return (e.ownerDocument || e)! == C && T (e), y (e, t)}, se.attr = function (e, t) {(e.ownerDocument || e)! == C && T (e); var n = b.attrHandle [t.toLowerCase ()], r = n && j.call (b.attrHandle, t.toLowerCase ())? n (e, t,! E): void 0; вернуть void 0! == r? r: d.attributes ||! е e.getAttribute (т) :( г = e.getAttributeNode (т)) && r.specified r.value:?. NULL}, se.escape = функция (е) {возвращение (е + "") заменить (ре, т.е.)}, se.error = function (e) {throw new Error ("Синтаксическая ошибка, нераспознанное выражение:" + e)}, se.uniqueSort = function (e) {var t, n = [], r = 0 , г = 0, если (! л = d.detectDuplicates, и = d.sortStable && e.slice (0), e.sort (D), л) {в то время (т = е [я ++]) === т е [I] && (г = n.push (я)), тогда как (г -) е.splice (n [r], 1)} return u = null, e}, o = se.getText = function (e) {var t, n = "", r = 0, i = e.nodeType; if (i ) {if (1 === i || 9 === i || 11 === i) {if ("string" == typeof e.textContent) вернуть e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} else if (3 === i || 4 === i) вернуть e.nodeValue} else, тогда как (t = e [r ++]) n + = o ( t); вернуть n}, (b = se.selectors = {cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, найти: {}, относительный: {">": {dir: "parentNode" , first:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", first:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {return e [1] = e [1] .replace (te, ne), e [3] = (e [3] || e [4] || e [5] || "") .replace (te, ne), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)} , РЕБЕНОК: function (e) {return e [1] = e [1] .toLowerCase (), "п-й "=== е [1] .slice (0,3)? (е [3] || se.error (е [0]), е [4] = + (е [4]? е [5] + (е [6] || 1): 2 * ( "даже" === е [3] || "нечетным" === е [3])), е [5] = + (е [7] + e [8] || "odd" === e [3])): e [3] && se.error (e [0]), e}, PSEUDO: function (e) {var t, n =! e [6] && e [2]; вернуть G.CHILD.test (e [0])? null: (e [3]? e [2] = e [4] || e [5] || "": п && X.test (п) && (Т = Н (п,! 0)) && (т = n.indexOf ( ")", n.length-т) -n.length) && (е [0] = E [ 0] .slice (0, t), e [2] = n.slice (0, t)), e.slice (0,3))}}, фильтр: {TAG: function (e) {var t = e.replace (te, ne) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t }}, CLASS: function (e) {var t = p [e + ""]; return t || (t = new RegExp ("(^ |" + M + ")" + e + "(" + M + "| $ ) ")) && p (e, function (e) {return t.test (" string ")== typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "")})}, ATTR: function (n, r, i) {возвращать функцию (e ) {var t = se.attr (e, n); вернуть ноль == t? "! =" === r:! r || (t + = "", "=" === r? t == = я: === г т == я: "=" === г я && 0 === t.indexOf (я): "=!"?!? "* =" === г я && - 1 <t.indexOf (i): "$ =" === r? i && t.slice (-i.length) === i: "~ =" === r? -1 <("" + t.replace (F, "") + "") .indexOf (i): "| =" === r && (t === i || t.slice (0, i.length + 1) === i + "- "))}}, РЕБЕНОК: функция (h, e, t, g, v) {var y =" nth "! == h.slice (0,3), m =" last "! == h.slice (-4), x = "типа" === e; return 1 === g && 0 === v? Function (e) {return !! e.parentNode}: function (e, t, n) { var r, i, o, a, s, u, l = y!? == м "NextSibling":!!! "PreviousSibling", с = e.parentNode, е = х && e.nodeName.toLowerCase (), р = п && х, д = 1, если (с) {если (у) { в то время как (л) {а = е; при этом (а = [л]), если (х a.nodeName.toLowerCase () === е: 1 === a.nodeType)! вернуться 1; U = L = "только" === ч && && у "NextSibling"} вернуться 0}, если (и = [м c.firstChild: c.lastChild], м && р)! {d = (s = (г = (г = (о = (а = с) [к] || ([к] = {})) [a.uniqueID] || (о [a.uniqueID] = {})) [ч] || []) [0] === s && г [1]) && г [2], а = s && c.childNodes [с], в то время (а = ++ с && && а [л] || (д = s = 0) || u.pop ()), если (1 === a.nodeType && ++ d && a === e) {i [h] = [S, s, d]; break}} иначе, если (p && (d = s = (r = (i = (o) = (а = е) [к] || ([к] = {})) [a.uniqueID] || (о [a.uniqueID] = {})) [ч] || []) [0 ] === s && г [1]) ,! 1 === г), а (а = ++ с && && а [л] || (d = s = 0) || u.pop ()), если ((х? .nodeName.toLowerCase () === е: 1 === a.nodeType) &&++ && д (р && ((я = (о = [к] || ([к] = {})) [a.uniqueID] || (о [a.uniqueID] = {})) [ч] = [S, d]), A === е)) перерыва; возвращение (D- = v) === г || д% г == 0 && 0 <= d / г}}}, пСЕВДО: функция (е , o) {var t, a = b.pseudos [e] || b.setFilters [e.toLowerCase ()] || se.error ("неподдерживаемое псевдо:" + e); вернуть a [k]? a ( o): 1 <a.length? (t = [e, e, "", o], b.setFilters.hasOwnProperty (e.toLowerCase ())? le (function (e, t) {var n, r = а (е, о), г = r.length, в то время (я -) е [п = Р (е, г [г])] = (т [п] = г [г])}): функция (e) {вернуть a (e, 0, t)}): a}}, псевдо: {not: le (function (e) {var r = [], i = [], s = f (e.replace) (B, "$ 1")); вернуть s [k]? Le (функция (e, t, n, r) {var i, o = s (e, null, r, []), a = e.length ; while (a -) (i = o [a]) && (e [a] =! (t [a] = i))}): function (e, t, n) {return r [0] = e, s (r, null, n, i), r [0] = null,! i.pop ()}}), имеет: le (function (t) {return function (e) {return 0 <se ( t, e) .length}}), содержит: le (function (t) {return t = t.replace (te,ne), function (e) {return-1 <(e.textContent || o (e)). indexOf (t)}}), lang: le (function (n) {return V.test (n || ") ") || se.error (" неподдерживаемый lang: "+ n), n = n.replace (te, ne) .toLowerCase (), function (e) {var t; do {if (t = E? e. языки: e.getAttribute ( "XML: Lang") || e.getAttribute ( "языки")) возвращение (т = t.toLowerCase ()) === п || 0 === t.indexOf (п + "- ")} while ((e = e.parentNode) && 1 === e.nodeType); return! 1}}), target: function (e) {var t = n.location && n.location.hash; вернуть t && t.slice (1) === e.id}, root: function (e) {return e === a}, focus: function (e) {return e === C.activeElement && (! C.hasFocus || C. hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)}, включено: ge (! 1), отключено: ge (! 0), проверено: function (e) {var t = e.nodeName.toLowerCase (); возвращение "вход" === т && !! e.checked || "вариант" === т && !! e.selected}, выбраны:function (e) {вернуть e.parentNode && e.parentNode.selectedIndex,! 0 === e.selected}, пусто: function (e) {for (e = e.firstChild; e; e = e.nextSibling) if (e .nodeType <6) return! 1; return! 0}, родитель: function (e) {return! b.pseudos.empty (e)}, заголовок: function (e) {return J.test (e.nodeName)} , input: function (e) {return Q.test (e.nodeName)}, button: function (e) {var t = e.nodeName.toLowerCase (); вернуть «input» === t && «button» == = e.type || "button" === t}, text: function (e) {var t; вернуть "input" === e.nodeName.toLowerCase () && "text" === e.type && ( нуль == (т = e.getAttribute ( "тип")) || "текст" === t.toLowerCase ())}, первый: ве (функция () {возвращение [0]}), последнее: пять ( функция (е, т) {вернуться [т-1]}), экв: ве (функция (е, т, п) {возвращение [п <0 п + т: п]}), даже: ве (функция ( e, t) {for (var n = 0; n <t; n + = 2) e.push (n); вернуть e}), нечетное: ve (функция (e,t) {for (var n = 1; n <t; n + = 2) e.push (n); return e}), lt: ve (функция (e, t, n) {for (var r = n < 0? N + t: t <n? T: n; 0 <= - r;) e.push (r); вернуть e}), gt: ve (функция (e, t, n) {for (var r = n <0? n + t: n; ++ r <t;) e.push (r); вернуть e})}}). pseudos.nth = b.pseudos.eq, {radio:! 0, флажок:! 0, файл:! 0, пароль:! 0, изображение:! 0}) b.pseudos [e] = de (e); для (e в {submit:! 0, сброс:! 0}) b .pseudos [e] = he (e); function me () {} function xe (e) {for (var t = 0, n = e.length, r = ""; t <n; t ++) r + = e [t] .value; return r} функция be (s, e, t) {var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, p = r ++; вернуть функцию e.first? (e, t, n) {while (e = e [u]) if (1 === e.nodeType || f) вернуть s (e, t, n); return! 1}: функция (e, t, n) {var r, i, o, a = [S, p]; if (n) {while (e = e [u]) if ((1 === e.nodeType || f) && s (e, t, n)) возвращает! 0} в то время как (e = e [u]) if (1 === e.nodeType || f) if (i = (o = е [к] || (е [к] = {})) [e.uniqueID] || (о [e.uniqueID] = {}), л && л === е.nodeName.toLowerCase ()) e = e [u] || e; else {if ((r = i [c]) && r [0] === S && r [1] === p) вернуть a [2] = r [2]; if ((i [c] = a) [2] = s (e, t, n)) return! 0} return! 1}} функция we (i) {return 1 <i.length? функция (e, t, n) {var r = i.length; while (r -) if (! i [r] (e, t, n)) возвращает! 1; возвращает! 0}: i [0] } функция Te (e, t, n, r, i) {для (var o, a = [], s = 0, u = e.length, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s))); вернуть функцию} Ce (d, h, g, v , y, e) {вернуть v &&! v [k] && (v = Ce (v)), y &&! y [k] && (y = Ce (y, e)), le (функция (e, t, n , r) {var i, o, a, s = [], u = [], l = длина t, c = e || функция (e, t, n) {для (var r = 0, i = t.length; r <i; r ++) se (e, t [r], n); return n} (h || "*", n.nodeType? [n]: n, []), f =! ! д || е && ч с: Те (с, с, д, п, г), р = г у || (е д: л || v?) []: т:??? е; если (г && г ( е, р, п, г), v) {я = Те (р, и), V (я, [], п, г), а = i.length, в то время (о -) (а = я [ O]) && (р [и [о]] =!(Е [и [о]] = а))}, если (е) {если (у || г) {если (у) {я = [], о = p.length, в то время (о -) (а = р [о]) && i.push (F [O] = а); у (нуль, р = [], I, R)} O = p.length, в то время (о -) (а = р [о ]) && - 1 <(i = y? P (e, a): s [o]) && (e [i] =! (T [i] = a))}} иначе p = Te (p == = t? p.splice (l, p.length): p), y? y (null, t, p, r): H.apply (t, p)})} функция Ee (e) {for (var i, t, n, r = длина e, o = b.relative [e [0] .type], a = o || b.relative [""], s = o? 1: 0, u = be (function (e) {return e === i}, a,! 0), l = be (function (e) {return-1 <P (i, e)}, a,! 0), c = [ function (e, t, n) {var r =! o && (n || t! == w) || ((i = t) .nodeType? u (e, t, n): l (e, t, n)); вернуть i = null, r}]; s <r; s ++) if (t = b.relative [e [s] .type]) c = [be (we (c), t)]; еще {если ((т = b.filter [е [с] .type] .Нанесите (нуль, е [с] .matches)) [K]) {для (n = ++ х; п <г; п ++), если (b.relative [e [n] .type]) break; вернуть Ce (1 <s && we (c), 1 <s && xe (e.slice (0, s-1) .concat ({value: "" === е [s-2] .Type "*": ""})). Заменить (B, "$ 1"), т, з <п && Ee (e.slice (с, п)), п <г && Ee (е = e.slice (п)), п <г && х (е)) } c.push (t)} return we (c)} return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) {var n, r, i, o, a, s, u, l = x [e + ""]; если (l) возвращает t? 0: l.slice (0); a = e, s = [], u = b. preFilter; while (a) {for (o в n &&! (r = _. exec (a)) || (r && (a = a.slice (r [0] .length) || a), s.push ( я = [])), п = 1, (г = z.exec (а)) && (п = r.shift (), i.push ({значение: п, тип: г [0] .Надеть ( B, "")}), a = a.slice (n.length)), b.filter)! (R = G [o] .exec (a)) || u [o] &&! (R = u [о] (г)) || (п = r.shift (), i.push ({значение: п, тип: о, соответствует: г}), а = a.slice (n.length)); если (! n) break} return t? a.length: a? se.error (e): x (e, s) .slice (0)}, f = se.compile = function (e, t) {var n , v, y, m, x, r, i = [], o = [], a = N [e + ""]; если (! a) {t || (t = h (e)), n = t.length; при этом (п -) (а = Ee (т [п])) [к] я?.толчок (а): o.push (а); (A = N (е, (v = О, т = 0 <(у = я) .length, х = 0 <v.length, г = функция (е, t, n, r, i) {var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find. TAG ( "*", я), Н = S + = NULL == р 1: Math.random () || 0,1, г = D.Length, ибо (я && (ш = Т === С || т || я), л == г && = нуль (о = д [л]);! л ++) {если (х && о) {а = 0, т || o.ownerDocument === С || (Т (о) , п = Е);!, а (с = v [A ++]), если (S (O, т || С, п)) {r.push (о); перерыв} я && (S = H)} м && (( о = ы && о) && и -, е && c.push (о))}, если (и + = л, м && л == и) {а = 0;!, а (с = у [A ++]) с (C, F, т , п), если (е) {если (0 <и), а (л -) с [л] || е [л] || (е [л] = q.call (г)); е = Те (f)} H.apply (r, f), i &&! e && 0 <f.length && 1 <u + y.length && se.uniqueSort (r)} return i && (S = h, w = p), c}, m? le (r): r))). selector = e} return a}, g = se.select = function (e, t, n, r) {var i, o, a, s, u, l = "function" == typeof e && e, c =!г && ч (е = l.selector || е); если (п = п || [], 1 === c.length) {если (2 <(O = C [0] = с [0] .slice ( 0)). длина && "ИД" === (а = о [0]). тип && 9 === t.nodeType && && E b.relative [O [1] .type]) {если (! (т = (b.find. ID (a.matches [0] .replace (te, ne), t) || []) [0])) return n; l && (t = t.parentNode), e = e.slice (o.shift ( ) .value.length)} г = G.needsContext.test (е) 0: o.length, в то время (я -) {если (а = о [I], b.relative [с = a.type] ) перерыва; если ((и = b.find [с]) && (г = и (a.matches [0] .Надеть (т, п), ee.test (о [0] .Type) && Ye (т. parentNode) || t))) {if (o.splice (i, 1),! (e = r.length && xe (o))) return H.apply (n, r), n; break}}} return ( л || е (е, с)) (г, т,! е, п,! т || ee.test (е) && вы (t.parentNode) || т), п}, d.sortStable = к. split (""). sort (D) .join ("") === k, d.detectDuplicates = !! l, T (), d.sortDetached = ce (function (e) {return 1 & e.compareDocumentPosition (C) .createElement (»fieldset "))}), ce (function (e) {return e.innerHTML =" <a href='#'> </a> "," # "=== e.firstChild.getAttribute (" href ") }) || fe ("type | href | height | width", функция (e, t, n) {if (! n) возвращает e.getAttribute (t, "type" === t.toLowerCase ()? 1 : 2)}), d.attributes && ce (function (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("value", ""), "" === e.firstChild. getAttribute ("value")}) || fe ("value", function (e, t, n) {if (! n && "input" === e.nodeName.toLowerCase ()) return e.defaultValue}), ce (function (e) {return null == e.getAttribute ("disabled")}) || fe (R, функция (e, t, n) {var r; if (! n) возвращает! 0 === е [т] t.toLowerCase () :( г = e.getAttributeNode (т)) && r.specified r.value:? NULL}), как таковые} (С); k.find = ч, k.expr = ч .selectors, k.expr [ ":«] = K.expr.pseudos, k.uniqueSort = k.unique = h.uniqueSort, k.text = h.getText, k.isXMLDoc = h.isXML, k.contains = h.contains, k.escapeSelector = ч .escape; var T = function (e, t, n) {var r = [], i = void 0! == n; while ((e = e [t]) && 9! == e.nodeType) if ( 1 === e.nodeType) {if (i && k (e) .is (n)) break; r.push (e)} return r}, S = function (e, t) {for (var n = [] ; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, N = k.expr.match.needsContext; функция A (e, t) {return e .nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()} var D = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; функция j (e, n, r) {return m (n)? k.grep ( e, функция (e, t) {return !! n.call (e, t, e)! == r}): n.nodeType? k.grep (e, function (e) {return e === n ! == r}): "строка"! = typeof n? k.grep (e, function (e) {return-1 <i.call (n, e)! == r}): k.filter (n , е, г)} k.filter = функция (е, т,n) {var r = t [0]; вернуть n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType? k.find.matchesSelector (r, e)? [r]: []: k.find.matches (e, k.grep (t, function (e) {return 1 === e.nodeType}))}, k.fn.extend ({найти : function (e) {var t, n, r = this.length, i = this; if ("string"! = typeof e) вернуть this.pushStack (k (e) .filter (function () {for (t) = 0; т <г; т ++), если (k.contains (я [т], это)) возвращают 0}));! для (п = this.pushStack ([]), т = 0; т <г; t ++) k.find (e, i [t], n); return 1 <r? k.uniqueSort (n): n}, filter: function (e) {вернуть this.pushStack (j (this, e || [] ,! 1))}, а не: function (e) {вернуть this.pushStack (j (this, e || [] ,! 0))}, is: function (e) {return !! j (this , "string" == typeof e && N.test (e)? k (e): e || [] ,! 1) .length}}); var q, L = / ^ (?: \ s * (<[ \ w \ W] +>) [^>] * | # ([\ w -] +)) $ /; (k.fn.init = function (e, t, n) {var r, i; if ( ! e) вернуть это; if (n = n || q, "string" == typeof e) {if (!(Г = "<" === е [0] && ">" === е [e.length-1] && 3 <= e.length [нуль, е, нуль]: L.exec (е)) ! || г [1] && т) возвращают т || t.jquery (т || п) .find (е):!? this.constructor (т) .find (е), если (г [1]) { if (t = t instanceof k? t [0]: t, k.merge (this, k.parseHTML (r [1], t && t.nodeType? t.ownerDocument || t: E,! 0)), D. test (r [1]) && k.isPlainObject (t)) для (r in t) m (this [r])? this [r] (t [r]): this.attr (r, t [r]) ; return this} return (i = E.getElementById (r [2])) && (this [0] = i, this.length = 1), this} return e.nodeType? (this [0] = e, this .length = 1, this): m (e)? void 0! == n.ready? n.ready (e): e (k): k.makeArray (e, this)}). prototype = k.fn , q = k (E); var H = / ^ (?: родители | пред. (?: до | все)) /, O = {дети:! 0, содержимое:! 0, следующее:! 0, пред .:! 0}; функция P (e, t) {while ((e = e [t]) && 1! == e.nodeType); return e} k.fn.extend ({has: function (e) {var t = k (е, это), n = t.length, вернуть это.filter (function () {for (var e = 0; e <n; e ++) if (k.contains (this, t [e])) return! 0})}, ближайший: function (e, t) {var n, r = 0, i = this.length, o = [], a = "string"! = typeof e && k (e); if (! N.test (e)) для (; r <i; r ++) для (п = это [г]; п && п == т; п = n.parentNode!), если (n.nodeType <11 && (-1 <a.index (п): 1 === n.nodeType && k.find?. matchSelector (n, e))) {o.push (n); break} возвращает this.pushStack (1 <o.length? k.uniqueSort (o): o)}, индекс: function (e) {return e? "string" == typeof e? i.call (k (e), this [0]): i.call (this, e.jquery? e [0]: e): this [0] && this [0]. parentNode? this.first (). prevAll (). length: -1}, add: function (e, t) {вернуть this.pushStack (k.uniqueSort (k.merge (this.get (), k (e, t))))}, addBack: function (e) {вернуть this.add (null == e? this.prevObject: this.prevObject.filter (e))}}), k.each ({parent: function ( e) {var t = e.parentNode; вернуть t && 11! == t.nodeType? t:null}, parent: function (e) {return T (e, "parentNode")}, parentUntil: function (e, t, n) {return T (e, "parentNode", n)}, следующий: function (e ) {return P (e, "nextSibling")}, prev: function (e) {return P (e, "previousSibling")}, nextAll: function (e) {return T (e, "nextSibling")}, prevAll : function (e) {return T (e, "previousSibling")}, nextUntil: function (e, t, n) {return T (e, "nextSibling", n)}, prevUntil: функция (e, t, n ) {return T (e, "previousSibling", n)}, братья и сестры: function (e) {return S ((e.parentNode || {}). firstChild, e)}, дети: function (e) {return S (e.firstChild)}, содержимое: function (e) {return "undefined"! = typeof e.contentDocument? e.contentDocument: (A (e, "template") && (e = e.content || e), k.merge ([], e.childNodes))}}, function (r, i) {k.fn [r] = function (e, t) {var n = k.map (this, i, e); возвращения «До»!== r.slice (-5) && (t = e), t && "string" == typeof t && (n = k.filter (t, n)), 1 <this.length && (O [r] || k .uniqueSort (n), H.test (r) && n.reverse ()), this.pushStack (n)}}); var R = / [^ \ x20 \ t \ r \ n \ f] + / g; function M (e) {return e} функция I (e) {throw e} функция W (e, t, n, r) {var i; try {e && m (i = e.promise)? i.call (e) .done (t) .fail (n): e && m (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r))} catch ( e) {n.apply (void 0, [e])}} k.Callbacks = function (r) {var e, n; r = "string" == typeof r? (e = r, n = {}, k.each (e.match (R) || [], функция (e, t) {n [t] =! 0}), n): k.extend ({}, r); var i, t, о, а, с = [], и = [], л = -1, с = функция () {для (A = A || r.once, о = = 0; u.length;! л = - 1) {т = u.shift (!); в то время как (++ л <s.length) 1 === с [л] .Нанесите (т [0], T [1]) && r.stopOnFalse && (L = ы !!! .length, т = 1)} r.memory || (т = 1), г = 1, а && (s = T []:? "")}, F = {добавить: функцию () {возвращение s && (t &&! i && (l = s.length-1, u.push (t)), функция n (e) {k.each (e, функция (e, t) {m (t)? r.unique && f. имеет (т) || s.push (т):! т && t.length && "строка" == ш (т) && п (т)})} (аргументы), т && я && с ()), это}, удалить: функция () {return k.each (arguments, function (e, t) {var n; while (-1 <(n = k.inArray (t, s, n))) s.splice (n, 1), n <= l && l -}), this}, имеет: function (e) {return e? -1 <k.inArray (e, s): 0 <s.length}, пусто: function () {return s && (s = []), это}, отключить: function () {return a = u = [], s = t = "", это}, отключено: function () {return! s}, lock: function () {return a = u = [], t || i || (s = t = ""), this}, locked: function () {return !! a}, fireWith: function (e, t) {return a || (т = [. е, (т = т || []) нарезать t.slice (): T], u.push (т), I || с ()), этот}, огонь: функция () {return f.fireWith (this, arguments), this}, fired: function () {return !! o}};return f}, k.extend ({Deferred: function (e) {var o = [["notify", "progress", k.Callbacks ("memory"), k.Callbacks ("memory"), 2], ["решить", "сделано", k.Callbacks ("однажды память"), k.Callbacks ("однажды память"), 0, "разрешено"], ["отклонить", "сбой", k.Callbacks (" Once memory "), k.Callbacks (" Once memory "), 1," Rejected "]], i =" Pending ", a = {state: function () {return i}, всегда: function () {return s .done (arguments) .fail (arguments), это}, «catch»: function (e) {return a.then (null, e)}, pipe: function () {var i = arguments; return k.Deferred ( function (r) {k.each (o, function (e, t) {var n = m (i [t [4]]) && i [t [4]]; s [t [1]] (function () {var e = n && n.apply (this, arguments); e && m (e.promise)? e.promise (). progress (r.notify) .done (r.resolve) .fail (r.отвергнуть): г [т [0] + "С"] (это, н [е]:?. аргументы)})}), я = NULL}) обещание ()}, то: функция (т, п, г ) {var u = 0; function l (i, o, a, s) {return function () {var n = this, r = аргументы, e = function () {var e, t; if (! (i < u)) {if ((e = a.apply (n, r)) === o.promise ()) бросить новый TypeError («возможное разрешение»); t = e && («object» == typeof e || "функция" == typeof e) && e.then, m (t)? s? t.call (e, l (u, o, M, s), l (u, o, I, s)): (и ++ t.call (е, л (и, о, M, s), л (и, о, я, с), л (и, о, М, o.notifyWith))) :( а! = = M && (n = void 0, r = [e]), (s || o.resolveWith) (n, r))}}, t = s? E: function () {try {e ()} catch ( e) {k.Deferred.exceptionHook && k.Deferred.exceptionHook (e, t.stackTrace), u <= i + 1 && (a! == I && (n = void 0, r = [e]), o.rejectWith (n , r))}}; i? t () :( k.Deferred.getStackHook && (t.stackTrace = k.Deferred.getStackHook ()), C.setTimeout (t))}} вернуть k.Отложенный (функция (е) {о [0] [3] .add (л (0, е, т (г) г: М, e.notifyWith)), O [1] [3] .add (л ( 0, е, м (т) т: M +)), о [2] [3] .add (L (0, е, т (п) п:?. Я))}) обещание ()}, обещание : function (e) {return null! = e? k.extend (e, a): a}}, s = {}; return k.each (o, function (e, t) {var n = t [2 ], г = т [5]; а [т [1]] = n.add, г && n.add (функция () {я = г}, о [3-е] [2] .disable, о [3- е] [3] .disable, о [0] [2] .lock, o [0] [3] .lock), n.add (т [3] .fire), S [T [0]] = функция () {return s [t [0] + "With"] (this === s? void 0: this, arguments), this}, s [t [0] + "With"] = n.fireWith}) , a.promise (s), e && e.call (s, s), s}, когда: function (e) {var n = arguments.length, t = n, r = Array (t), i = s.call (аргументы), o = k.Deferred (), a = function (t) {return function (e) {r [t] = this, i [t] = 1 <arguments.length? s.call (arguments): е - п || o.resolveWith (г, я)}};.! если (п <= 1 && (Ш (е, o.done (а (т)) решения, o.reject, п),» ожидание "=== o.state () || м (я [т] && я [т].затем))) return o.then (); while (t -) W (i [t], a (t), o.reject); return o.promise ()}}); var $ = / ^ ( Eval | Внутренний | Диапазон | Ссылка | Синтаксис | Тип | URI) Ошибка $ /;. k.Deferred.exceptionHook = функция (е, т) {C.console && C.console.warn && е && $ тест (e.name) && C.console. warn ("исключение jQuery.Deferred:" + e.message, e.stack, t)}, k.readyException = function (e) {C.setTimeout (function () {throw e})}; var F = k. Deferred (); function B () {E.removeEventListener ("DOMContentLoaded", B), C.removeEventListener ("загрузка", B), k.ready ()} k.fn.ready = function (e) {return F .then (е) [ "улов"] (функция (е) {k.readyException (е)}), это}, k.extend ({isReady: 1, readyWait: 1, готов: функция (е) {( ! 0 === е - k.readyWait:! k.isReady) || (k.isReady = 0) == е && 0 <- k.readyWait || F.resolveWith (е, [к])} }), k.ready.then = F.then, "полный" === E.readyState ||»loading "! == E.readyState &&! E.documentElement.doScroll? C.setTimeout (k.ready) :( E.addEventListener (" DOMContentLoaded ", B), C.addEventListener (" load ", B)); var _ = функция (e, t, n, r, i, o, a) {var s = 0, u = длина e, l = null == n; if ("object" === w (n)) для (s в i =! 0, n) _ (e, t, s, n [s] ,! 0, o, a), иначе if (void 0! == r && (i =! 0, m (r) || (a =! 0), l && (a? (t.call (e, r), t = null) :( l = t, t = function (e, t, n) {return l.call (k ? (е), п)})), т)) для (; s <и; s ++), т (е [с], п, а г: r.call (е [с], с, т (е [ s], n))); return i? e: l? t.call (e): u? t (e [0], n): o}, z = / ^ - ms - /, U = / - ([az]) / g; функция X (e, t) {return t.toUpperCase ()} function V (e) {return e.replace (z, "ms -"). replace (U, X)} var G = function (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + E.nodeType}; function Y () {this.expando = k.expando + Y.uid ++} Y.uid = 1, Y.prototype = {cache: function (e) {var t = e [this.expando]; return t || (t = {}, G (e) && (E.nodeType е [this.expando] = т:? Object.defineProperty (е, this.expando, {значение: т, настраивается: 0}))), т}, набор: функция (е, т, n) {var r, i = this.cache (e); if ("строка" == typeof t) i [V (t)] = n; еще для (r в t) i [V (r)] = t [r]; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [V (t) ]}, access: function (e, t, n) {return void 0 === t || t && "string" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t, n), void 0! == n? n: t)}, remove: function (e, t) {var n, r = e [this.expando]; if (void 0! == r ) {if (void 0! == t) {n = (t = Array.isArray (t)? t.map (V) :( t = V (t)) в r? [t]: t.match ( R) || []). Length; while (n -) delete r [t [n]]} (void 0 === t || k.isEmptyObject (r)) && (e.nodeType? E [this .expando] = void 0: удалить e [this.expando])}}, hasData: function (e) {var t = e [this.expando]; вернуть void 0! == t &&! k.isEmptyObject (t)} }; var Q = новый Y, J = новый Y,K = / ^ (?: \ {[\ W \ W] * \} | \ [[\ w \ W] * \]) $ /, Z = / [AZ] / g; функция ee (e, t, n) {var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data -" + t.replace (Z, "- $ &"). toLowerCase (), " строка "== TypeOf (п = e.getAttribute (г))) {попробуйте {п =" истина "=== (я = п) ||" ложь "! == я && (" нулевой "=== я? null: i === + i + ""? + i: K.test (i)? JSON.parse (i): i)} catch (e) {} J.set (e, t, n)} иначе n = void 0; return n} k.extend ({hasData: function (e) {return J.hasData (e) || Q.hasData (e)}, data: function (e, t, n) {return J. доступ (e, t, n)}, removeData: функция (e, t) {J.remove (e, t)}, _ данные: функция (e, t, n) {возврат Q.access (e, t, n )}, _ removeData: function (e, t) {Q.remove (e, t)}}), k.fn.extend ({data: function (n, e) {var t, r, i, o = this [0], a = o && o.attributes; if (void 0 === n) {if (this.length && (i = J.get (o), 1 === o.nodeType &&! Q.get (o, ") hasDataAttrs "))) {т = a.length;в то время как (т -) а [т] && 0 === (г = а [т] .name) .indexOf ( "данные -") && (г = V (r.slice (5)), й (о, r, i [r])); Q.set (o, "hasDataAttrs",! 0)} return i} return "object" == typeof n? this.each (function () {J.set (this, n )}): _ (this, function (e) {var t; if (o && void 0 === e) вернуть void 0! == (t = J.get (o, n))? t: void 0! = = (t = ee (o, n))? t: void 0; this.each (function () {J.set (this, n, e)})}, ноль, e, 1 <arguments.length, null ,! 0)}, removeData: function (e) {вернуть this.each (function () {J.remove (this, e)})}}), k.extend ({queue: function (e, t, n ) {var r; if (e) возвращает t = (t || "fx") + "queue", r = Q.get (e, t), n && (! r || Array.isArray (n)? r = Q.access (е, т, k.makeArray (п)): r.push (п)), г || []}, Dequeue: функция (е, т) {Т = Т || "FX"; var n = k.queue (e, t), r = n.length, i = n.shift (), o = k._queueHooks (e, t); "inprogress" === i && (i = n.shift (), г -), я && (»fx "=== t && n.unshift (" inprogress "), удалить o.stop, i.call (e, function () {k.dequeue (e, t)}, o)) ,! r && o && o.empty.fire ( )}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; вернуть Q.get (e, n) || Q.access (e, n, {empty: k.Callbacks ("единовременная память") ) .add (function () {Q.remove (e, [t + "queue", n])})})}}), k.fn.extend ({queue: function (t, n) {var e = 2; вернуть "строку"! = Typeof t && (n = t, t = "fx", e -), arguments.length <e? K.queue (this [0], t): void 0 === n ? this: this.each (function () {var e = k.queue (this, t, n); k._queueHooks (this, t), "fx" === t && "inprogress"! == e [0] ] && k.dequeue (this, t)})}, dequeue: function (e) {вернуть this.each (function () {k.dequeue (this, e)})}, clearQueue: function (e) {вернуть this .queue (e || "fx", [])}, обещание: function (e, t) {var n, r = 1, i = k.Deferred (), o = это, a = это.длина, s = функция () {- r || i.resolveWith (o, [o])}; "строка"! = typeof e && (t = e, e = void 0), e = e || "fx "; while (a -) (n = Q.get (o [a], e +" queueHooks ")) && n.empty && (r ++, n.empty.add (s)); вернуть s (), i.promise (t)}}); var te = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, ne = new RegExp ( "^ (?: ([+ -]) = |) (" + тэ + ") ([аз%] *) $", "я"), п = [, "Right", "Низ "Вверх" "," Left "], т.е. = E.documentElement, oe = function (e) {return k.contains (e.ownerDocument, e)}, ae = {составе:! 0}; ie.getRootNode && (oe = function ( e) {return k.contains (e.ownerDocument, e) || e.getRootNode (ae) === e.ownerDocument}); var se = function (e, t) {return "none" === (e = т || е) .style.display || "" === e.style.display && ОЕ (е) && "нет" === k.css (е, "дисплей")}, и ^ = функция (е, т, п,r) {var i, o, a = {}; для (o в t) a [o] = e.style [o], e.style [o] = t [o]; для (o в i = n .apply (e, r || []), t) e.style [o] = a [o]; return i}; функция le (e, t, n, r) {var i, o, a = 20 , s = r? function () {return r.cur ()}: function () {return k.css (e, t, "")}, u = s (), l = n && n [3] || ( k.cssNumber [т] "?": "ПВ"), с = e.nodeType && (k.cssNumber [т] || "ПВ" == && л + и) && ne.exec (k.css (е, т )); если (с && с [3] == л) {и / = 2, L = L || с [3], с = + и || 1;! при этом (а) - (е k.style, т, с + л), (1-о) * (1- (O = s () / и || 0,5)) <= 0 && (а = 0), с / = о; с * = 2, к .style (e, t, c + l), n = n || []} return n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1 ) * n [2]: + n [2], r && (r.unit = l, r.start = c, r.end = i)), i} var ce = {}; функция fe (e, t) {for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c <f; c ++) (r = e [c]). style && ( п = r.style.display, т? ( "нет" === п && (л [с] = Q.get (г, "дисплей") || нуль, л [с] || (г.style.display = "")), "" === r.style.display && se (r) && (l [c] = (u = a = o = void 0, a = (i = r) .ownerDocument, s = i.nodeName, (и = се [с]) || (о = a.body.appendChild (a.createElement (ы)), и = k.css (о, "дисплей"), o.parentNode.removeChild (о), "нет" === у && (и = "блок"), се [с] = и)))): "нет" == п && (л [с] = "нет", Q.set (r, "display", n))); для (c = 0; c <f; c ++) null! = l [c] && (e [c] .style.display = l [c]); вернуть e } k.fn.extend ({show: function () {return fe (this,! 0)}, hide: function () {return fe (this)}, toggle: function (e) {return "boolean" == typeof e? e? this.show (): this.hide (): this.each (function () {se (this)? k (this) .show (): k (this) .hide ()})} }); var pe = / ^ (?: checkbox | radio) $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) / i, он = / ^ $ | ^ модуль $ | \ / (?: Java | ECMA) скрипт / я, GE = {вариант: [1, "<выберите несколько = 'несколько'> "," </ select> "], thead: [1," <таблица> "," </ table> "], столбец: [2," <таблица> <colgroup> ", "</ COLGROUP> </ таблицы>"], тр: [2, "<таблица> <TBODY>", "</ TBODY> </ таблицы>"], тд: [3, "<таблица> <TBODY> <tr> "," </ tr> </ tbody> </ table> "], _ по умолчанию: [0," "," "]}; функция ve (e, t) {var n; return n =" undefined "! = typeof e.getElementsByTagName? e.getElementsByTagName (t ||" * "):" undefined "! = typeof e.querySelectorAll? e.querySelectorAll (t ||" * "): [], void 0 === t || t && A (e, t)? k.merge ([e], n): n} функция ye (e, t) {для (var n = 0, r = e.length; n <r; n ++) Q.set (е [п], "globalEval!", т || Q.get (т [п], "globalEval"))} GE.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; var me, xe, be = / <| & #? \ w +; /; функция we (e, t, n, r, i) {для (var o, a, s, u, l, c, f = t.createDocumentFragment (), p = [], d = 0, h = e.length; д <ч; d ++), если ((о = е [г]) || 0 === о), если ( "объект" === ш (о)) k.merge (р, o.nodeType ? [o]: o); иначе if (be.test (o)) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || [ "", ""]) [1] .toLowerCase (), и = GE [с] || ge._default, a.innerHTML = и [1] + k.htmlPrefilter (о) + и [2], с = u [0]; while (c -) a = a.lastChild; k.merge (p, a.childNodes), (a = f.firstChild) .textContent = ""} иначе p.push (t.createTextNode ( o)); f.textContent = "", d = 0; while (o = p [d ++]) if (r && - 1 <k.inArray (o, r)) i && i.push (o), иначе if (l = ае (о), а = ве (f.appendChild (о), "сценарий"), л && вы (а), п) {с = 0, в то время (о = [C ++]) he.test (o.type || "") && п.push (o)} return f} me = E.createDocumentFragment (). appendChild (E.createElement ("div")), (xe = E.createElement ("input")). setAttribute ("type", "radio" ), xe.setAttribute ( "проверено", "проверено"), xe.setAttribute ( "имя", "т"), me.appendChild (х), y.checkClone = me.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, me.innerHTML = "<textarea> x </ textarea>", y.noCloneChecked = !! me.cloneNode (! 0) .lastChild.defaultValue; var Te = / ^ key /, Ce = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke () {return! 0} function Se () {return! 1} function Ne (e, t) {return e === function () {try {return E.activeElement} catch (e) {}} () == ("focus" === t)} функция Ae (e, t, n, r, i, o) {var a, s; if ("объект" == typeof t) {for (s в "строке"! = typeof n && ( r = r || n, n = void 0),t) Ae (e, s, n, r, t [s], o); вернуть e} if (null == r && null == i? (i = n, r = n = void 0): null == i && ("строка" == typeof n? (i = r, r = void 0) :( i = r, r = n, n = void 0)) ,! 1 === i) i = Se; еще, если ( ! i) return e; return 1 === o && (a = i, (i = function (e) {return k (). off (e), a.apply (this, arguments)}). guid = a. guid || (a.guid = k.guid ++)), e.each (function () {k.event.add (this, t, i, r, n)})} function De (e, i, o) {o? (Q.set (e, i,! 1), k.event.add (e, i, {пространство имен:! 1, обработчик: function (e) {var t, n, r = Q.get ( this, i); if (1 & e.isTrigger && this [i]) {if (r.length) (k.event.special [i] || {}). DelegateType && e.stopPropagation (); еще if (r = s.call (аргументы), Q.set (это, я, г), т = O (это, я), это [I] (), г! == (п = Q.get (это, я)) || т Q.set (this, i,! 1): n = {}, r! == n) return e.stopImmediatePropagation (), e.preventDefault (), n.value} else r.length && (Q.set ( это, я, {значение: k.event.trigger (k.extend (г [0], k.Event.prototype), т.slice (1), this)}), e.stopImmediatePropagation ())}})): void 0 === Q.get (e, i) && k.event.add (e, i, ke)} k.event = {global: {}, add: function (t, e, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Q.get (т), если (V) {n.handler && (п = (о = п) .handler, я = o.selector), я && k.find.matchesSelector (т.е. я), n.guid || (n.guid = k.guid ++), (и = v.events) || (и = v.events = {}), (а = v.handle) || (а = v.handle = функция (е) {возвращение "не определено "! = typeof k && k.event.triggered! == e.type? k.event.dispatch.apply (t, arguments): void 0}), l = (e = (e ||" "). match (R .) || [ ""]) длиной, в то время (л -) д = г = (s = Ee.exec (е [л]) || []) [1], H = (s [2] | "(..?") сортировки (в), г && (е = k.event.special [d] || {}, д = (я f.delegateType: f.bindType) | ") разделение" || д, е = k.event.special [d] || {}, с = k.extend ({типа: д, OrigType: г, данные: г, обработчик: п, справы: n.guid, селектор: я, needsContext: я && k.expr.match.needsContext.test (I),Пространство имен: h.join ( "")}, о), (р = и [d]) || ((р = и [D] = []) delegateCount = 0, f.setup && 1 ==.! f.setup.call (т, г, д, а) || t.addEventListener && t.addEventListener (д, а)), f.add && (f.add.call (т, с), c.handler.guid || ? (c.handler.guid = n.guid)), я p.splice (p.delegateCount ++ 0, с): p.push (с), k.event.global [d] = 0)}}, remove: function (e, t, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Q.hasData (e) && Q.get ( е), если (V && (и = v.events)) {л = (т = (т || "") совпадают (R) ||. [ ""]) длина;., а (л -), если ( д = G = (s = Ee.exec (т [л]) || []) [1], H = (s [2] || ""). раскол ( ""). рода (), д ) {е = k.event.special [d] || {}, р = и [d = (г f.delegateType: f.bindType) || д] || [], s = s [2] && новый RegExp ( "(^ | \\)." + h.join ( "\\ (:.?.. * \\ |)") + "(\\ | $)"), а = о = р. длина;!, а (о -) с = р [о] ,! я && г == c.origType || п && n.guid == c.guid || s && s.test (с!.Пространство имен) || г && г == c.selector && ( "**" == г || c.selector) || (p.splice (о, 1!), c.selector && p.delegateCount -, f.remove && е .remove.call (е, с));! && && p.length (f.teardown && 1 == f.teardown.call (е, ч, v.handle!!) || k.removeEvent (д, д, v .handle), удалите u [d])} иначе для (d in u) k.event.remove (e, d + t [l], n, r,! 0); k.isEmptyObject (u) && Q.remove (e, «обрабатывать события»)}}, dispatch: function (e) {var t, n, r, i, o, a, s = k.event.fix (e), u = новый массив (arguments.length) ), л = (Q.get (это, "события") || {}) [s.type] || [], с = k.event.special [s.type] || {}; для (U [0] = s, т = 1, т <arguments.length; т ++) и [т] = аргументы [т];!! если (s.delegateTarget = это, c.preDispatch || 1 == c.preDispatch .call (это, с)) {а = k.event.handlers.call (это, s, L), т = 0, тогда как ((я = а [T ++]) && s.isPropagationStopped ()) {ы! .currentTarget = i.elem, п = 0, тогда как ((о = я.Обработчики [п ++]) &&! s.isImmediatePropagationStopped ()) s.rnamespace &&! 1! == o.namespace &&! s.rnamespace.test (o.namespace) || (s.handleObj = О, s.data = о. data, void 0! == (r = ((k.event.special [o.origType] || {}). handle || o.handler) .apply (i.elem, u)) &&! 1 == = (s.result = r) && (s.preventDefault (), s.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (this, s), s.result}}, обработчики: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click" === e.type && 1 <= e .button)) для (;! л == это;! л = l.parentNode || это), если (1 === l.nodeType && ( "щелчок" == e.type || 0 == л!. отключено)) {для (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [n]). selector + ""] && ( а [I] = r.needsContext -1 <к (я, это) .index (л):?. k.find (я, это, нуль, [л]) длины), а [I] && o.push ( г); о.длина && s.push ({elem: l, обработчики: o})} return l = this, u <t.length && s.push ({elem: l, обработчики: t.slice (u)}), s}, addProp: функция (t, e) {Object.defineProperty (k.Event.prototype, t, {enumerable:! 0, настраиваемый:! 0, получить: m (e)? function () {if (this.originalEvent) вернуть e (this .originalEvent)}: function () {if (this.originalEvent) возвращает this.originalEvent [t]}, set: function (e) {Object.defineProperty (this, t, {enumerable:! 0, настраивается:! 0, доступное для записи:! 0, значение: e})}})}, исправление: function (e) {return e [k.expando]? e: new k.Event (e)}, специальное: {load: {noBubble :! 0}, нажмите: {setup: function (e) {var t = this || e; вернуть pe.test (t.type) && t.click && A (t, "input") && De (t, "click", ke) ,! 1}, триггер: function (e) {var t = this || e; вернуть pe.test (t.type) && t.click && A (t, "input") && De (t, "click") ,! 0 }, _ default: function (e) {var t = e.target; return pe.test (t.type) && t.click && A (t, "input") && Q.get (t, "click") || A (t, "a")}}, до загрузки: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)}}}}, k.removeEvent = function (e, t, n) {e.removeEventListener && e.removeEventListener (t , n)}, k.Event = function (e, t) {if (! (этот экземпляр k.Event)) возвращает новый k.Event (e, t); e && e.type? (this.originalEvent = e, this .type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue? ke: Se, this.target = e.target && 3 === e.target .nodeType e.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = е, т && k.extend (это, т), this.timeStamp = е && е .timeStamp || Date.now (), это [k.expando] =!0}, k.Event.prototype = {constructor: k.Event, isDefaultPrevented: Se, isPropagationStopped: Se, isImmediatePropagationStopped: Se, isSimulated:! 1, protectDefault: function () {var e = this.originalEvent; this.isDefaultPrevented ke, e &&! this.isSimulated && e.preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = ke, e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () е = this.originalEvent; this.isImmediatePropagationStopped = KE, е && && this.isSimulated e.stopImmediatePropagation (), this.stopPropagation ()}}, k.each ({клавишу Alt:!! 0, пузыри: 0, 0: отменяемый, changedTouches: 0, ctrlKey: 0, деталь: 0, EventPhase: 0, metaKey: 0, pageX: 0, Пейджи: 0, shiftKey: 0, вид: 0, "символ" :! 0, код: 0, charCode: 0, ключ: 0, KEYCODE: 0, кнопка: 0, кнопки: 0, clientX: 0, clientY: 0, OffsetX: 0,offsetY:! 0, pointerId:! 0, pointerType:! 0, screenX:! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, касается:! 0, который: function (e) {var t = e.button; return null == e.which && Te.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! == t && Ce.test (e.type) ? 1 & т 1: 2 & т 3: 4 & т 2: 0: e.which}}, k.event.addProp), k.each ({фокус: "focusin", размытие: "focusout"}, функция (е, t) {k.event.special [e] = {setup: function () {return De (this, e, Ne) ,! 1}, триггер: function () {return De (this, e) ,! 0} , delegateType: т}}), k.each ({MouseEnter: "Mouseover", MouseLeave: "MouseOut", pointerenter: "pointerover", pointerleave: "pointerout"}, функция (е, я) {k.event.special [e] = {DelegateType: i, bindType: i, handle: function (e) {var t, n = e.relatedTarget, r = e.handleObj; вернуть n && (n === это || k.contains (this , п)) || (e.type = г.origType, t = r.handler.apply (this, arguments), e.type = i), t}}}), k.fn.extend ({on: function (e, t, n, r) {вернуть Ae (this, e, t, n, r)}, one: function (e, t, n, r) {return Ae (this, e, t, n, r, 1)}, off: function (e, t, n) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, k (e.delegateTarget) .off (r.namespace? r.origType + "." + r.namespace: r.origType, r.selector, r.handler), this; if ("объект" == typeof e) {для (i в e) this.off (i, t, e [ i]); вернуть это} return! 1! == t && "function"! = typeof t || (n = t, t = void 0) ,! 1 === n && (n = Se), this.each ( function () {k.event.remove (this, e, n, t)})}}); var je = / <(?! area | br | col | embed | hr | img | input | link | meta | пары) (([AZ] [^ \ / \ 0> \ x20 \ т \ г \ п \ е] *) [^>] *) \ /> / г, QE = / <сценарий | <стиль | <ссылка /i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--) | (?: \] \] | -)> \ s * $ / g; функция Oe (e, t) {return A (e, "таблица") && A (11! == t.nodeType? t: t .firstChild, "tr") && k (e) .children ("tbody") [0] || e} функция Pe (e) {return e.type = (null! == e.getAttribute ("type")) + "/" + e.type, e} function Re (e) {return "true /" === (e.type || "") .slice (0,5)? e.type = e.type.slice (5): e.removeAttribute ("type"), e} функция Me (e, t) {var n, r, i, o, a , S, U, L, если (1 === t.nodeType) {если (Q.hasData (е) && (о = Q.access (е), а = Q.set (т, о), л = o.events)) для (я удаляю a.handle, a.events = {}, l) для (n = 0, r = l [i]. длина; n <r; n ++) k.event.add ( т, I, L [я] [п]); J.hasData (е) && (ы = J.access (е), и = k.extend ({}, с), J.set (т, и) )}} функция Ie (n, r, i, o) {r = g.apply ([], r); var e, t, a, s, u, l, c = 0, f = n.length, p = f-1, d = r [0], h = m (d); if (h || 1 <f && "string" == typeof d &&! y.checkClone && Le.test (d)) return n.each ( function (e) {var t = n.eq (e); h && (r [0] = d.call (this, e, t.html ())), т. е. (t, r, i, o)}) ; если (е && (т = (е = мы (г, п [0] .ownerDocument, 1, N, O)) FirstChild, 1 === e.childNodes!..Длина && (е = т), т || о)) {для (с = (а = k.map (в (е, "сценарий"), П)) длиной;. с <е; C ++) и = е, с! == р && (и = k.clone (и,! 0,! 0), s && k.merge (а, в (и, "сценарий"))), i.call (п [с], и, с ); если (ов) для (л = а [a.length-1] .ownerDocument, k.map (а, Ре), с = 0; с <с; C ++) и = а [с], he.test (u.type || "") &&! Q.access (и, "globalEval") && k.contains (л, и) && (u.src && "модуль"! == (u.type || ""). ?! toLowerCase () k._evalUrl && && u.noModule k._evalUrl (u.src, {нонс: u.nonce || u.getAttribute ( "Нонс")}): Ь (u.textContent.replace (Он, "") , u, l))} return n} функция We (e, t, n) {for (var r, i = t? k.filter (t, e): e, o = 0; ноль! = (r = я [о]!), о ++) п ||-== r.nodeType || k.cleanData (в (г)), r.parentNode && (п && аи (г) && вы (в (г, "сценарий")), r.parentNode.removeChild (r)); вернуть e} k.extend ({htmlPrefilter: function (e) {return e.replace (je, "<$ 1> </ $ 2>")}, clone: ​​function (e, t, n) {var r, i, o, a, s , и, л, с = e.cloneNode, F = ае (е) (0!);!, если ((y.noCloneChecked || 1 == e.nodeType && 11 == e.nodeType || k.isXMLDoc (! д.))) для (а = в (с), г = 0, г = (о = в (е)) длина; г <я; г ++), с = о [г], и = а [г], void 0, "input" === (l = u.nodeName.toLowerCase ()) && pe.test (s.type)? u.checked = s.checked: "input"! == l && "textarea"! == л || (u.defaultValue = s.defaultValue); если (т), если (п) при (о = о || в (е), а = || в (С), г = 0, г = о .length; r <i; r ++) Me (o [r], a [r]); иначе Me (e, c); return 0 <(a = ve (c, "script")). length && ye (a, ! f && ve (e, "script")), c}, cleanData: function (e) {for (var t, n, r, i = k.event.special, o = 0; void 0! == (n = e [o]); o ++) if (G (n)) {if (t = n [Q.expando]) {if (t.events) для (r в t.events) i [r]? k.event .remove (п, г): k.removeEvent (п, г, т.handle); n [Q.expando] = void 0} n [J.expando] && (n [J.expando] = void 0)}}}), k.fn.extend ({detach: function (e) { return We (this, e,! 0)}, remove: function (e) {return We (this, e)}, text: function (e) {return _ (this, function (e) {return void 0 == = е k.text (это):?.!!! this.empty () каждая (функция () {1 == this.nodeType && 11 == this.nodeType && 9 == this.nodeType || (this.textContent = е) })}, null, e, arguments.length)}, append: function () {return Ie (this, arguments, function (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this. nodeType || Oe (this, e) .appendChild (e)})}, prepend: function () {return Ie (this, аргументы, function (e) {if (1 === this.nodeType || 11 == = this.nodeType || 9 === this.nodeType) {var t = Oe (this, e); t.insertBefore (e, t.firstChild)}})}, before: function () {return Ie (this , аргументы, функция (е) {this.parentNode && this.parentNode.insertBefore (е, это)})}, после того, как:function () {return Ie (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, empty: function () {for (var e, t = 0; null ! = (e = this [t]); t ++) 1 === e.nodeType && (k.cleanData (ve (e,! 1)), e.textContent = ""); вернуть this}, clone: ​​function ( e, t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return k.clone (this, e, t)})}, html: function (e) {return _ (this, function (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) ) return t.innerHTML; if ("string" == typeof e &&! qe.test (e) &&! ge [(de.exec (e) || ["", ""])) [1] .toLowerCase () ]) {е = k.htmlPrefilter (е); попытаться {для (; п <г;. п ++), 1 === (Т = это [п] || {}) NODETYPE && (k.cleanData (ве (т, ! 1)), t.innerHTML = е); т = 0} поймать (е) {}} т && this.empty () добавление (е)}, нуль, е, arguments.length)}, ReplaceWith.:function () {var n = []; вернуть Ie (this, аргументы, function (e) {var t = this.parentNode; k.inArray (this, n) <0 && (k.cleanData (ve (this))), т && t.replaceChild (е, это))}, п)}}), k.each ({appendTo: "добавить", prependTo: "" добавьте в начале InsertBefore: "до", InsertAfter: "после", replaceAll: "ReplaceWith "}, function (e, a) {k.fn [e] = function (e) {для (var t, n = [], r = k (e), i = r.length-1, o = 0 ; о <= я; о ++), т = о === я это:?! this.clone (0), к (г [о]) [а] (т), u.apply (п, t.get ( )); вернуть this.pushStack (n)}}); var $ e = new RegExp ("^ (" + te + ") (?! px) [az%] + $", "i"), Fe = функция (e) {var t = e.ownerDocument.defaultView; вернуть t && t.opener || (t = C), t.getComputedStyle (e)}, Be = new RegExp (re.join ("|"), "i" ); function _e (e, t, n) {var r, i, o, a, s = e.style; return (n = n || Fe (e)) && (""! == (a = n ,GetPropertyValue (т) || п [т]) || ае (е) || (а = k.style (е, т)) ,! y.pixelBoxStyles () && $ e.test (а) && Be.test ( т) && (г = s.width, я = s.minWidth, о = s.maxWidth, s.minWidth = s.maxWidth = s.width = а, а = n.width, s.width = г, с. minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} функция ze (e, t) {return {get: function () {if (! e ()) return ( this.get = t) .apply (this, аргументы); удалите this.get}}}! function () {function e () {if (u) {s.style.cssText = "position: absolute; left: - 11111px; ширина: 60px; рентабельность-топ: 1px; обивка: 0; границы: 0" , u.style.cssText = "положение: относительный; дисплей: блок; коробчатый проклейки: границы окна; переполнения: прокрутки; поле: auto; border: 1px; отступ: 1px; ширина: 60%; top: 1% ", т.е. .appendChild (s) .appendChild (u); var e = C.getComputedStyle (u); n =" 1% "! == e.top, а = 12 === т (e.marginLeft), u.style.right = "60%", о = 36 === т (e.right), г = 36 === т (e.width), u.style.position =»absolute ", i = 12 === t (u.offsetWidth / 3), т.е. .removeChild (s), u = null}} функция t (e) {return Math.round (parseFloat (e))} var n, г, I, O, A, s = E.createElement ( "DIV"), и = E.createElement ( "DIV"); u.style && (u.style.backgroundClip = "содержание-бокс", u.cloneNode ( ! 0) .style.backgroundClip = "", y.clearCloneStyle = "content-box" === u.style.backgroundClip, k.extend (y, {boxSizingReliable: function () {return e (), r}, pixelBoxStyles: function () {return e (), o}, pixelPosition: function () {return e (), n}, reliableMarginLeft: function () {return e (), a}, scrollboxSize: function () {return e (), i}}))} (); var Ue = ["Webkit", "Moz", "ms"], Xe = E.createElement ("div"). style, Ve = {}; функция Ge ( e) {var t = k.cssProps [e] || Ve [e]; вернуть t || (e в Xe? e: Ve [e] = function (e) {var t = e [0] .toUpperCase ( ) + e.slice (1), п = Ue.length;while (n -) if ((e = Ue [n] + t) в Xe) возвращает e} (e) || e)} var Ye = / ^ (none | table (?! - c [ea]) +.) /, Qe = / ^ - /, JE = {положение: "абсолютное", видимость: "скрытый", дисплей: "блок"}, {Ка = letterSpacing: "0", FontWeight: "400"} ; функция Ze (e, t, n) {var r = ne.exec (t); return r? Math.max (0, r [2] - (n || 0)) + (r [3] || "px"): t} функция et (e, t, n, r, i, o) {var a = "width" === t? 1: 0, s = 0, u = 0; if (n = == (r? "border": "content")) return 0; for (; a <4; a + = 2) "margin" === n && (u + = k.css (e, n + re [a]) ,! 0, я)), г? ( "содержание" === п && (и- = k.css (е, "заполнение" + повторно [а] ,! 0, я)), "запас"! == п && (и- = k.css (е, "граница" + повторно [а] + "ширина",! 0, я))) :( и + = k.css (е, "заполнение" + повторно [а], !? 0, я), "заполнение" == п и + = k.css (е, "граница" + повторно [а] + "Ширина", 0, я): s + = k.css (е,»Граница "+ повторно [а] +" Ширина», 0, я));! возврата г && 0 <= о && (и + = Math.max (0, Math.ceil (е [ "смещение" + T [0] .toUpperCase () + t.slice (1)] - ous-.5)) || 0), u} функция tt (e, t, n) {var r = Fe (e), i = (! y.boxSizingReliable ( ) || п) && "граница-бокс" === k.css (е, "boxSizing!", 1, г), о = я, а = _e (е, т, г), с = "смещение" + t [0] .toUpperCase () + t.slice (1); if ($ e.test (a)) {if (! n) return a; a = "auto"} return (! y.boxSizingReliable () && || я "авто" === а ||! parseFloat (а) && "встроенный" === k.css (е, "дисплей",! 1, г)) && e.getClientRects (). длина && (я = "border-box" === k.css (e, "boxSizing",! 1, r), (o = s в e) && (a = e [s])), (a = parseFloat (a) | | 0) + et (e, t, n || (i? "Border": "content"), o, r, a) + "px"} функция nt (e, t, n, r, i) { вернуть новый nt.prototype.init (e, t, n, r,i)} k.extend ({cssHooks: {opacity: {get: function (e, t) {if (t) {var n = _e (e, "opacity"); return "" === n? "1 «: п}}}}, cssNumber: {animationIterationCount: 0, ColumnCount: 0, fillOpacity: 0, flexGrow: 0, flexShrink: 0, FontWeight: 0, gridArea: 0, GridColumn: 0 , gridColumnEnd: 0, gridColumnStart: 0, gridRow: 0, gridRowEnd: 0, gridRowStart: 0, LineHeight: 0, непрозрачность: 0, заказ: 0, дети-сироты: 0, вдовы: 0 , ZIndex: 0, масштабирование: 0}, cssProps: {}, стиль: функция (е, т, п, г) {если (е && 3 == e.nodeType && 8 == e.nodeType && e.style!!) {вар I, O, A, s = V (T), и = Qe.test (т), л = e.style; если (и || (т = Се (ы)), а = k.cssHooks [т] || k.cssHooks [s], void 0 === n) вернуть && "get" в && void 0! == (i = a.get (e,! 1, r))? i: l [t]; "строка" === (o = typeof n) && (i = ne.exec (n)) && i [1] && (n = le (e, t, i), o = "число"), null! = п && п == п && (»номер "( ":" точек ") == о || у || п + = я && я [3] || (k.cssNumber [s]?)!"!, y.clearCloneStyle ||" "== п || 0! == t.indexOf ("background") || (l [t] = "наследовать"), && "set" в && void 0 === (n = a.set (e, n, r)) | | (u? l.setProperty (t, n): l [t] = n))}}, css: function (e, t, n, r) {var i, o, a, s = V (t) ; вернуть Qe.test (t) || (t = Ge (s)), (a = k.cssHooks [t] || k.cssHooks [s]) && "get" в a && (i = a.get ( e,! 0, n)), void 0 === i && (i = _e (e, t, r)), "normal" === i && t в Ke && (i = Ke [t]), "" == ? = п || п (о = parseFloat (я) ,! 0 === п || isFinite (O) O || 0: I):}}), k.each ([ "высота",» ширина "], функция (е, и) {k.cssHooks [и] = {получаем: функцию (д, т, п) {если (т) возвращают Ye.test (k.css (е,!" дисплей ") .) || e.getClientRects () длина && e.getBoundingClientRect () ширина TT (е, и, п):.? ие (е, JE,function () {return tt (e, u, n)})}, set: function (e, t, n) {var r, i = Fe (e), o =! y.scrollboxSize () && "absolute" === i.position, а = (о || п) && "граница-бокс" === k.css (е, "boxSizing!", 1, я), s = п? и др (е, и, n, a, i): 0; вернуть a & o o && (s- = Math.ceil (e ["offset" + u [0] .toUpperCase () + u.slice (1)] - parseFloat (i [u]) - и др (е, и, "граница", 1, я!) -.! 5)), с && (г = ne.exec (т)) && "ПВ" == (г [3] || "ПВ") && (e.style [и] = т, т = k.css (е, и)), З (0, т, с)}}}), k.cssHooks.marginLeft = г (y.reliableMarginLeft, функция ( e, t) {if (t) return (parseFloat (_e (e, "marginLeft")) || e.getBoundingClientRect (). left-ue (e, {marginLeft: 0}, function () {return e.getBoundingClientRect () .left})) + "точек"}), k.each ({поле: "", обивка: "", граница: "Ширина"}, функция (I, O) {k.cssHooks [I + о ] = {вставит:function (e) {for (var t = 0, n = {}, r = "string" == typeof e? e.split (""): [e]; t <4; t ++) n [i + re [t] + o] = r [t] || r [t-2] || r [0]; return n}}, «запас»! == i && (k.cssHooks [i + o] .set = Ze)}), k.fn.extend ({css: function (e, t) {return _ (this, function (e, t, n) {var r, i, o = {}, a = 0; если (Array.isArray (т)) {для (г = Ре (е), I = t.length; а <я; A ++) O [т [а]] = k.css (е, т [а] ,! 1, r); return o} return void 0! == n? K.style (e, t, n): k.css (e, t)}, e, t, 1 <arguments.length)}}) , ((k.Tween = нт) .prototype = {конструктор: нт, INIT: функция (е, т, п, г, I, O) {this.elem = е, this.prop = п, this.easing = я || k.easing._default, this.options = т, this.start = this.now = this.cur (), this.end = г, this.unit = о || (k.cssNumber [п]? "": "px")}, cur: function () {var e = nt.propHooks [this.prop]; вернуть e && e.get? e.get (this): nt.propHooks._default.get (this)} , запустите: function (e) {var t, n = nt.propHooks [this.prop]; верните это.? Options.duration this.pos = т = k.easing [this.easing] (е, е * this.options.duration, 0,1, this.options.duration): this.pos = т = е, это. Теперь = (this.end-this.start) * T + this.start, this.options.step && this.options.step.call (this.elem, this.now, это), п && n.set? n.set (это ): nt.propHooks._default.set (this), this}}). init.prototype = nt.prototype, (nt.propHooks = {_ default: {get: function (e) {var t; return 1! == e.elem.nodeType || нуль! = e.elem [e.prop] && NULL == e.elem.style [e.prop]? e.elem [e.prop] :( т = k.css (е. эль, e.prop, "")) && "авто" == т т:? 0}, набор: функция (е) {k.fx.step [e.prop] k.fx.step [е?. проп] (е): 1 == e.elem.nodeType || k.cssHooks [e.prop] && нуль == e.elem.style [Ge (e.prop)] e.elem [e.prop!? ] = e.now: k.style (e.elem, e.prop, e.now + e.unit)}}}) scrollTop = nt.propHooks.scrollLeft = {множество:. функция (е) {e.elem .nodeType && e.elem.parentNode && (е.elem [e.prop] = e.now)}}, k.easing = {linear: function (e) {return e}, swing: function (e) {return.5-Math.cos (e * Math.PI ) / 2}, _ по умолчанию: "swing"}, k.fx = nt.prototype.init, k.fx.step = {}; var rt, it, ot, at, st = / ^ (?: toggle | show | скрыть) $ /, ut = / queueHooks $ /; функция lt () {it && (! 1 === E.hidden && C.requestAnimationFrame? C.requestAnimationFrame (lt): C.setTimeout (lt, k.fx.interval) , k.fx.tick ())} function ct () {return C.setTimeout (function () {rt = void 0}), rt = Date.now ()} функция ft (e, t) {var n, г = 0, г = {высота: е}, ибо (т = т 1: 0; г <4; R + = 2-Т) я [ "запас" + (N = Re [г])] = я [ "padding" + n] = e; вернуть t && (i.opacity = i.width = e), i} функция pt (e, t, n) {for (var r, i = (dt.tweeners [t] | . | []) Concat (dt.tweeners [ "*"]), о = 0, а = i.length; о <а; о ++), если (г = я [о] .call (п, т, е) ) return r} функция dt (o, e, t) {var n, a, r = 0, i = dt.prefilters.length, s = k.Deferred (). always (function () {delete u.elem}), u = function () {if (a) возвращает! 1; для (var e = rt || ct (), t = Math.max (0, l.startTime + l.duration-e), n = 1- (t / l.duration || 0), r = 0, i = l.tweens.length; r <i; r ++) l.tweens [r] .run (n); вернуть s.notifyWith (o , [л, п, т]), п <1 && я т: (I || s.notifyWith (O, [л, 1,0]), s.resolveWith (O, [л]) ,! 1)} , л = s.promise ({эль: о, реквизит: k.extend ({}, е), выбирает: k.extend (0, {specialEasing: {}, ослабление: k.easing._default}, т) , originalProperties: e, originalOptions: t, startTime: rt || ct (), длительность: t.duration, tweens: [], createTween: функция (e, t) {var n = k.Tween (o, l.opts , e, t, l.opts.specialEasing [e] || l.opts.easing); вернуть l.tweens.push (n), n}, stop: function (e) {var t = 0, n = e ? l.tweens.length: 0; если (a) вернуть это; для (a =! 0; t <n; t ++) l.tweens [t] .run (1); вернуть e? (s.notifyWith (o , [л, 1,0]), s.resolveWith (O, [л, е])): s.rejectWith (O, [л, е]), это}}), C = l.props; для ( ! function (e, t) {var n, r, i, o, a; для (n в e) if (i = t [r = V (n)], o = e [n], Array.isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, удалить e [n]), (a = k .cssHooks [r]) && "раскрыть" в a) для (n в o = a.expand (o), удалить e [r], o) n в e || (e [n] = o [n], t [n] = i); иначе t [r] = i} (c, l.opts.specialEasing); r <i; r ++) if (n = dt.prefilters [r] .call (l, o, c) , l.opts)) return m (n.stop) && (k._queueHooks (l.elem, l.opts.queue) .stop = n.stop.bind (n)), n; вернуть k.map (c , пт, л), м (l.opts.start) && l.opts.start.call (о, л), l.progress (l.opts.progress) .done (l.opts.done, l.opts. полный) .fail (l.opts.fail) .always (l.opts.always), k.fx.timer (k.extend (и, {элем: о, Anim: л, очереди: l.opts.queue} )), l} k.Animation = k.extend (dt, {tweeners: {"*": [function (e, t) {var n = this.createTween (e, t); вернуть le (n.elem, е, ne.exec (т), п), п}]}, Tweener: функция (е, т) {т (е) (т = е, е = [ "*"]): е = e.match (R); для (var n, r = 0, i = длина e; r <i; r ++) n = e [r], dt.tweeners [n] = dt.tweeners [n] || [], dt.tweeners [n] .unshift (t)}, предварительные фильтры: [function (e, t, n) {var r, i, o, a, s, u, l, c , f = "ширина" в t || "высота" в t, p = this, d = {}, h = e.style, g = e.nodeType && se (e), v = Q.get (e, "fxshow "); for (r в n.queue || (null == (a = k._queueHooks (e," fx ")). unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty .fire = функция () {a.unqueued || с ()}), a.unqueued ++ p.always (функция () {p.always (функция () {a.unqueued -, k.queue (е, "fx"). length || a.empty.fire ()})})), t) if (i = t [r], st.test (i)) {if (удалить t [r], o = o || "toggle" === i, i === (g? "hide": "show")) {if ("show"! == i ||! v || void 0 === v [ г]) продолжить;! г = 0} д [г] = v && v [г] || k.style (! е, г)}, если ((и = k.isEmptyObject (т)) || k.isEmptyObject ( d)) для (r в f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.Показано) && (л = Q.get (е, "дисплей")), "нет" === (с = k.css (е, "дисплей")) && (л с = л: (Fe ([ е] ,! 0), л = e.style.display || л, с = k.css (е, "дисплей"), Fe ([е]))), ( "встроенный" === с || "встроенный блок" === с нулевым &&! = л) && "нет" === k.css (е, "плавать") && (и || (p.done (функция () {h.display = л} ), нуль == л && (с = h.display, л = "нет" === с "?": с)), h.display = "встроенный блок")), n.overflow && (h.overflow = "скрытые", p.always (функция () {h.overflow = n.overflow [0], h.overflowX = n.overflow [1], h.overflowY = n.overflow [2]})), и = ! 1, d) u || (v? "Скрыто" в v && (g = v.hidden): v = Q.access (e, "fxshow", {display: l}), o && (v.hidden =! g), g && fe ([e] ,! 0), p.done (function () {for (r в g || fe ([e]), Q.remove (e, "fxshow"), d) k. стиль (е, г,d [r])})), u = pt (g? v [r]: 0, r, p), r в v || (v [r] = u.start, g && (u.end = u. начать, u.start = 0))}], предфильтр: функция (е, т) {т dt.prefilters.unshift (е): dt.prefilters.push (е)}}), k.speed = функция ( e, t, n) {var r = e && "object" == typeof e? k.extend ({}, e): {complete: n ||! n && t || m (e) && e, продолжительность: e, замедление : n && t || t &&! m (t) && t}; return k.fx.off?r.duration=0:"number"!=typeof r.duration && (r.duration in k.fx.speeds? r.duration = k.fx.speeds [r.duration]:! r.duration = k.fx.speeds._default), нуль = r.queue && 0 == r.queue || (r.queue = "FX"), r.old = r.complete, r.complete = функция () {т (r.old) && r.old.call (это), r.queue && k.dequeue (это, r.queue)}, г}, к. fn.extend ({fadeTo: function (e, t, n, r) {return this.filter (se) .css ("opacity", 0) .show (). end (). animate ({opacity: t} , е, п, г)}, анимация: функция (т, е, п,r) {var i = k.isEmptyObject (t), o = k.speed (e, n, r), a = function () {var e = dt (this, k.extend ({}, t), o ); (i || Q.get (this, "finish")) && e.stop (! 0)}; return a.finish = a, i ||! 1 === o.queue? this.each (a ): this.queue (o.queue, a)}, stop: function (i, e, o) {var a = function (e) {var t = e.stop; удалить e.stop, t (o)} ; вернуть "строку"! = typeof i && (o = e, e = i, i = void 0), e &&! 1! == i && this.queue (i || "fx", []), this.each (функция () {var e =! 0, t = null! = i && i + "queueHooks", n = k.timers, r = Q.get (this); if (t) r [t] && r [t] .stop && a (r [t]); иначе для (t in r) r [t] && r [t] .stop && ut.test (t) && a (r [t]); для (t = n.length; t -;) n [ т] .elem! == это || нуль! = я && п [т] .queue! == я || (п [т] .anim.stop (о), е =! 1, n.splice (т, 1 )) ;! е && о || k.dequeue (это, я)})}, отделка:! функция (а) {вернуться 1 == && (а = || "FX"), это.each (function () {var e, t = Q.get (this), n = t [a + "queue"], r = t [a + "queueHooks"], i = k.timers, o = n? n. длина: 0; для (! t.finish = 0, k.queue (это, а, []), г && && r.stop r.stop.call (это, 0), е = i.length; E--;) я [е] .elem === это && я [е] .queue === && (я [е] .anim.stop (0), i.splice (е, 1)!), ибо (е = 0; е <o; e ++) n [e] && n [e] .finish && n [e] .finish.call (this); delete t.finish})}}), k.each (["toggle", "show", " скрыть "], функция (e, r) {var i = k.fn [r]; k.fn [r] = функция (e, t, n) {вернуть ноль == e ||" логическое значение "== typeof е i.apply (это, аргументы): this.animate (! фт (г, 0), е, т, п)}}), k.each ({slideDown: футы ( "шоу"), slideUp: футы ( "скрыть"), slideToggle: футы ( "переключение"), FadeIn: {непрозрачности: "шоу"}, FADEOUT: {непрозрачности: "скрыть"}, fadeToggle: {непрозрачности: "тумблер"}}, функция (е, г) {к.fn [e] = function (e, t, n) {вернуть this.animate (r, e, t, n)}}), k.timers = [], k.fx.tick = function () {var e , т = 0, п = k.timers, ибо (Rt = Date.now (); т <n.length; т ++)! (е = п [т]) () || п [т] == е | | n.splice (t -, 1); n.length || k.fx.stop (), rt = void 0}, k.fx.timer = function (e) {k.timers.push (e) , k.fx.start ()}, k.fx.interval = 13, k.fx.start = функция () {это || (это =! 0, л ())}, k.fx.stop = функция () {it = null}, k.fx.speeds = {slow: 600, fast: 200, _default: 400}, k.fn.delay = function (r, e) {return r = k.fx && k.fx. speed [r] || r, e = e || "fx", this.queue (e, function (e, t) {var n = C.setTimeout (e, r); t.stop = function () { C.clearTimeout (п)}})}, а = E.createElement ( "вход"), при = E.createElement ( "выбрать"). AppendChild (E.createElement ( "вариант")), ot.type =» флажок», y.checkOn = ""! == ot.value, y.optSelected = at.selected, (а = E.createElement ( "вход")). значение = "т", Ot.type = "radio", y.radioValue = "t" === ot.value; var ht, gt = k.expr.attrHandle; k.fn.extend ({attr: function (e, t) {return _ ( this, k.attr, e, t, 1 <arguments.length)}, removeAttr: function (e) {вернуть this.each (function () {k.removeAttr (this, e)})}}), k. extend ({attr: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) возвращает "undefined" == typeof e. GetAttribute? k.prop (е, т, п) :( 1 === о && k.isXMLDoc (е) || (я = k.attrHooks [t.toLowerCase ()] || (k.expr.match.bool. test (t)? ht: void 0)), void 0! == n? null === n? void k.removeAttr (e, t): i && "set" в i && void 0! == (r = i. set (e, n, t))? r: (e.setAttribute (t, n + ""), n): i && "get" в i && null! == (r = i.get (e, t))? r : null == (r = k.find.attr (e, t))? void 0: r)}, attrHooks: {тип: {set: function (e, t) {if (! y.radioValue && "radio" === т && А ​​(е,»input ")) {var n = e.value; вернуть e.setAttribute (" type ", t), n && (e.value = n), t}}}}, removeAttr: function (e, t) {var n , г = 0, г = т && t.match (R), если (я && 1 === e.nodeType), а (п = я [г ++]) e.removeAttribute (п)}}), ХТ = {множество: функция ( е, т, п) {вернуться 1 === т k.removeAttr (е, п):? e.setAttribute (п, п), п}}, k.each (k.expr.match.bool.source .match (/ \ w + / g), функция (e, t) {var a = gt [t] || k.find.attr; gt [t] = function (e, t, n) {var r, i , o = t.toLowerCase (); вернуть n || (i = gt [o], gt [o] = r, r = null! = a (e, t, n)? o: null, gt [o] = i), r}}); var vt = / ^ (?: input | select | textarea | button) $ / i, yt = / ^ (?: a | area) $ / i; функция mt (e) { return (e.match (R) || []). join ("")} function xt (e) {return e.getAttribute && e.getAttribute ("class") || ""} function bt (e) {return Array .isArray (e)? e: "string" == typeof e && e.match (R) || []} k.fn.extend ({prop: function (e, t) {return _ (this,k.prop, e, t, 1 <arguments.length)}, removeProp: function (e) {вернуть this.each (function () {удалить это [k.propFix [e] || e]})}}) , k.extend ({prop: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) return 1 === o && k .isXMLDoc (e) || (t = k.propFix [t] || t, i = k.propHooks [t]), void 0! == n? i && "set" в i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "get" in i && null! == (r = i.get (e, t))? r: e [t]} , propHooks: {tabIndex: {get: function (e) {var t = k.find.attr (e, "tabindex"); return t? parseInt (t, 10): vt.test (e.nodeName) || yt.test (e.nodeName) && e.href 0: -1}}}, propFix: { "за": "htmlFor", "класс": "имя класса"}}), y.optSelected || (к. propHooks.selected = {get: function (e) {var t = e.parentNode; вернуть t && t.parentNode && t.parentNode.selectedIndex, null}, установить:function (e) {var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}), k.each (["tabIndex", "readOnly", "maxLength", "cellSpacing" , "CELLPADDING", "RowSpan", "COLSPAN", "useMap", "frameBorder", "contentEditable"], функция () {k.propFix [this.toLowerCase ()] = это}), k.fn.extend ({addClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (m (t)) возвращает this.each (function (e) {k (this). addClass (t.call (это, е, х (это)))});. (если (е = Ь (т)) длины) в то время как (п = это [и ++]), если (я = х (п), r = 1 === n.nodeType && "" + mt (i) + "") {a = 0; while (o = e [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + ""); i! == (s = mt (r)) && n.setAttribute ("class", s)} вернуть это}, removeClass: function (t) {var e, n, r, i, o, а, с, и = 0;if (m (t)) возвращает this.each (function (e) {k (this) .removeClass (t.call (this, e, xt (this)))}); if (! arguments.length) возвращает this .attr ( "класс", ""); (. (е = Ь (т)) длины), если в то время как (п = это [и ++]), если (я = х (п), г = 1 === п. nodeType && "" + mt (i) + "") {a = 0; while (o = e [a ++]) while (-1 <r.indexOf ("" + o + "")) r = r.replace (" "+ o +" "," "); i! == (s = mt (r)) && n.setAttribute (" class ", s)} вернуть это}, toggleClass: function (i, t) {var o = typeof i, a = "string" === o || Array.isArray (i); вернуть "логическое значение" == typeof t && a? t? this.addClass (i): this.removeClass (i): m (i)? this.each (function (e) {k (this) .toggleClass (i.call (this, e, xt (this), t), t)}): this.each (function () {var e, t, п, г; если (а) {т ​​= 0, п = к (это), г = Ь (я), в то время (е = г [т ++]) n.hasClass (е) n.removeClass (е): n.addClass (e)} иначе void 0! == i &&"Логическое"! == о || ((е = х (это)) && Q.set (это, "__ __ имя класса", е), this.setAttribute && this.setAttribute ( "класс", е ||! 1 === я ? "": Q.get (this, "__ className __") || ""))})}, hasClass: function (e) {var t, n, r = 0; t = "" + e + ""; while (n = this [r ++]) if (1 === n.nodeType && - 1 <("" + mt (xt (n)) + "") .indexOf (t)) return! 0; return! 1}} ); var wt = / \ r / g; k.fn.extend ({val: function (n) {var r, e, i, t = this [0]; вернуть arguments.length? (i = m (n) ), this.each (function (e) {var t; 1 === this.nodeType && (null == (t = i? n.call (this, e, k (this) .val ()): n) ? t = "": "number" == typeof t? t + = "": Array.isArray (t) && (t = k.map (t, function (e) {return null == e? "": e + ""})), (г = k.valHooks [this.type] || k.valHooks [this.nodeName.toLowerCase ()]) && "установить"в r && void 0! == r.set (this, t, "value") || (this.value = t))})): t? (r = k.valHooks [t.type] || k.valHooks [t.nodeName.toLowerCase ()]) && "get" в r && void 0! == (e = r.get (t, "value"))? e: "string" == typeof (e = t.value) ? e.replace (wt, ""): null == e? "": e: void 0}}), k.extend ({valHooks: {option: {get: function (e) {var t = k. find.attr (e, "value"); вернуть null! = t? t: mt (k.text (e))}}}, выбрать: {get: function (e) {var t, n, r, i = e.options, о = e.selectedIndex, а = "Select-один" === e.type, s = нуль: [], и = а о + 1: i.length, ибо (г = о? <0 и: А о:?! 0; г <и; г ++), если (. ((п = я [г]) выбран || г === о) && n.disabled && (n.parentNode.disabled ||! A (n.parentNode, "optgroup"))) {if (t = k (n) .val (), a) return t; s.push (t)} return s}, set: function (e , t) {var n, r, i = e.options, o = k.makeArray (t), a = i.length; while (a -) ((r = i [a]).selected = -1 <k.inArray (k.valHooks.option.get (r), o)) && (n =! 0); вернуть n || (e.selectedIndex = -1), o}}}}) , k.each (["radio", "checkbox"], function () {k.valHooks [this] = {set: function (e, t) {if (Array.isArray (t)) return e.checked = -1 <k.inArray (k (e) .val (), t)}}, y.checkOn || (k.valHooks [this] .get = function (e) {return null === e.getAttribute ( "value")? "on": e.value})}), y.focusin = "onfocusin" в C; var Tt = / ^ (?: focusinfocus | focusoutblur) $ /, Ct = function (e) {e .stopPropagation ()}; k.extend (k.event, {trigger: function (e, t, n, r) {var i, o, a, s, u, l, c, f, p = [n | ? | е], д = v.call (е, "тип") e.type: е, ч = v.call (е, "пространство имен") e.namespace.split ( ""): []; !!!, если (о = е = а = п = п || Е, 3 == n.nodeType && 8 == n.nodeType && Tt.test (д + k.event.triggered) && (- 1 <d.indexOf ( " ") && (д = (Н = d.split (".")).shift (), h.sort ()), u = d.indexOf (":") <0 && "on" + d, (e = e [k.expando]? e: новый объект k.Event (d, ") "== typeof e && e)). isTrigger = r? 2: 3, e.namespace = h.join (". "), e.rnamespace = e.namespace? new RegExp (" (^ | \\.) "+ h.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, e.result = void 0, e.target || (e.target = п), т = NULL == т [е]:?! k.makeArray (т, [е]), с = k.event.special [d] || {}, г || c.trigger || ! 1! == c.trigger.apply (п, т))) {если (! г &&! c.noBubble &&! х (п)) {для (с = c.delegateType || д, Tt.test (s + г) || (о = o.parentNode); а; о = o.parentNode) p.push (о), а = о, А === (n.ownerDocument || Е) && p.push (a.defaultView || a.parentWindow || С)} = 0, тогда как ((о = р [я ++]) && e.isPropagationStopped ()) е = о, e.type = 1 <с:? c.bindType | | д, (л = (Q.get (о, "события") || {}) [e.type] && Q.get (о, "обработки")) && l.apply (о, т),(l = u && o [u]) && l.apply && G (o) && (e.result = l.apply (o, t) ,! 1 === e.result && e.preventDefault ()); return e.type = d, г || e.isDefaultPrevented () || c._default &&! 1! == c._default.apply (p.pop (), т) ||! С (п) || и && т (п [d]) &&! х (п) && ((а = п [и]) && (п [и] = нуль), k.event.triggered = д, e.isPropagationStopped () && f.addEventListener (д, Ct), п [d] (), e.isPropagationStopped () && f.removeEventListener (d, Ct), k.event.triggered = void 0, a && (n [u] = a)), e.result}}, имитировать: функцию (e, t , n) {var r = k.extend (new k.Event, n, {type: e, isSimulated:! 0}); k.event.trigger (r, null, t)}}), k.fn. extended ({trigger: function (e, t) {вернуть this.each (function () {k.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; если (n) возвращает k.event.trigger (e, t, n,! 0)}}), y.focusin || k.each ({focus: "focusin", blur: "focusout "}, function (n, r) {var i = function (e) {k.event.simulate (r, e.target, k.event.fix (e))}; k.event.special [r] = {setup: function () {var e = this.ownerDocument || this, t = Q.access (e, r); t || e.addEventListener (n, i,! 0), Q.access (e, r, (t || 0) +1)}, разрыв: function () {var e = this.ownerDocument || this, t = Q.access (e, r) -1; t? Q.access (e, r, t) :( e.removeEventListener (n, i,! 0), Q.remove (e, r))}}}); var Et = C.location, kt = Date.now (), St = / \? /; k.parseXML = function (e) {var t; if (! e || "string"! = typeof e) вернуть null; try {t = (new C.DOMParser) .parseFromString (e, "text / xml ")} catch (e) {t = void 0} return t &&! t.getElementsByTagName (" parsererror "). length || k.error (" Неверный XML: "+ e), t}; var Nt = / \ [\] $ /, В = / \ г \ п / г, Dt = / ^ (?: отправить | кнопка | изображение | сброс | файл)? $ / я, JT = / ^ (?: вход | выбрать | textarea | keygen) / i; функция qt (n, e, r, i) {var t; if (Array.isArray (e)) k.each (e, function (e,t) {r || Nt.test (n)? i (n, t): qt (n + "[" + ("объект" == typeof t && null! = t? e: "") + "]", t , r, i)}); еще, если (r || "объект"! == w (e)) i (n, e); еще для (t в e) qt (n + "[" + t + "]" , e [t], r, i)} k.param = function (e, t) {var n, r = [], i = function (e, t) {var n = m (t)? t () : т; г [r.length] = encodeURIComponent (е) + "=" + encodeURIComponent (нуль == п "?": п)}, если (нуль == е) возвращение ""; если (Array.isArray ( e) || e.jquery &&! k.isPlainObject (e)) k.each (e, function () {i (this.name, this.value)}); еще для (n в e) qt (n, e [n], t, i); return r.join ("&")}, k.fn.extend ({serialize: function () {return k.param (this.serializeArray ())}, serializeArray: function ( ) {return this.map (function () {var e = k.prop (this, "elements"); return e? k.makeArray (e): this}). filter (function () {var e = this. type; вернуть this.name &&! k (this).есть ( ": отключено") && jt.test (this.nodeName) && Dt.test (е) && (this.checked || pe.test (е)!)}) отображение (функция (е, т) {!. var n = k (this) .val (); return null == n? null: Array.isArray (n)? k.map (n, function (e) {return {name: t.name, value: e. replace (At, "\ r \ n")}}): {имя: t.name, значение: n.replace (At, "\ r \ n")}}). get ()}}); var Lt = /% 20 / g, Ht = / #. * $ /, Ot = / ([? &]) _ = [^ &] * /, Pt = / ^ (. *?): [\ T] * ( [^ \ г \ п] *) $ / г, Rt = / ^ (?: GET | ГОЛОВА) $ /, Mt = / ^ \ / \ //, It = {}, Wt = {}, $ т = "* /". concat ("*"), Ft = E.createElement ("a"); function Bt (o) {return function (e, t) {"string"! = typeof e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase (). match (R) || []; if (m (t)) while (n = i [r ++]) "+" = == п [0]? (п = n.slice (1) || "*", (о [п] = о [п] || []). unshift (т)) :( о [п] = o [n] || []). push (t)}} функция _t (t, i, o, a) {var s = {}, u = t === Wt; функция l (e) {var r ;return s [e] =! 0, k.each (t [e] || [], функция (e, t) {var n = t (i, o, a); вернуть «строку»! = typeof n | | u || s [n]? u?! (r = n): void 0: (i.dataTypes.unshift (n), l (n) ,! 1)}), r} вернуть l (i.dataTypes [0]) ||! S ["*"] && l ("*")} функция zt (e, t) {var n, r, i = k.ajaxSettings.flatOptions || {}; for (n в t ) void 0! == t [n] && ((i [n]? e: r || (r = {})) [n] = t [n]); вернуть r && k.extend (! 0, e, г), е} Ft.href = Et.href, k.extend ({активна: 0, LastModified: {}, ETag: {}, {ajaxSettings: URL: Et.href, тип: "GET", isLocal: / ^ (. ?: о | приложение | приложение-хранение | + - расширение | файл | Рез | виджет): $ / тест (Et.protocol), глобальный: 0, ProcessData: 0, асинхронная: 0, CONTENTTYPE.!! : "application / x-www-form-urlencoded; charset = UTF-8", принимает: {"*": $ t, text: "text / plain", html: "text / html", xml: "application / xml, text / xml ", json:" application / json, text / javascript "},Содержание: {XML: / \ bxml \ б /, HTML: / \ bhtml /, JSON: / \ bjson \ б /}, responseFields: {XML: "responseXML", текст: "responseText", JSON: "responseJSON"} , преобразователи: {"* text": String, "text html":! 0, "text json": JSON.parse, "text xml": k.parseXML}, flatOptions: {url:! 0, context:! 0 }}, ajaxSetup: function (e, t) {return t? zt (zt (e, k.ajaxSettings), t): zt (k.ajaxSettings, e)}, ajaxPrefilter: Bt (It), ajaxTransport: Bt ( Wt), ajax: function (e, t) {"object" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r , ч, г, I, O, V = k.ajaxSetup ({}, т), у = v.context || v, м = v.context && (y.nodeType || y.jquery)? к (у) : k.event, x = k.Deferred (), b = k.Callbacks («однажды память»), w = v.statusCode || {}, a = {}, s = {}, u = «отменено» , T = {readyState: 0, getResponseHeader: function (e) {var t; if (h) {if (! N) {n = {}; while (t = Pt.exec (p)) n [t [1 ].toLowerCase () + ""] = (n [t [1] .toLowerCase () + ""] || []). concat (t [2])} t = n [e.toLowerCase () + ""] } return null == t? null: t.join (",")}, getAllResponseHeaders: function () {return h? p: null}, setRequestHeader: function (e, t) {вернуть null == h && (e = s [e.toLowerCase ()] = s [e.toLowerCase ()] || e, a [e] = t), this}, overrideMimeType: function (e) {return null == h && (v.mimeType = e) ), это}, statusCode: function (e) {var t; if (e) if (h) T.always (e [T.status]); еще для (t in e) w [t] = [w [ t], e [t]]; вернуть это}, прервать: function (e) {var t = e || u; вернуть c && c.abort (t), l (0, t), это}}; if (x .promise (T), v.url = ((е || v.url || Et.href) + ""). заменить (Мт, Et.protocol + "//"), v.type = t.method | |.. t.type || v.method || v.type, v.dataTypes = (v.dataType || "*") toLowerCase () матч (R) || [ ""], нуль == v. crossDomain) {г = E.createElement ( "а"); попытаться {г.HREF = v.url, r.href = r.href, v.crossDomain = Ft.protocol + "//" + Ft.host! = r.protocol + "//" + r.host} поймать (е) {v. crossDomain =! 0}} if (v.data && v.processData && "string"! = typeof v.data && (v.data = k.param (v.data, v.traditional)), _ t (It, v, t, T ), h) вернуть T; for (i in (g = k.event && v.global) && 0 == k.active ++ && k.event.trigger ("ajaxStart"), v.type = v.type.toUpperCase () , v.hasContent =! Rt.test (v.type), е = v.url.replace (Ht, ""), v.hasContent? v.data && v.processData && 0 === (v.contentType || "") .indexOf ( "применение / х-WWW-форм-urlencoded") && (v.data = v.data.replace (Лт, "+")) :( а = v.url.slice (f.length), v .data && (v.processData || "string" == typeof v.data) && (f + = (St.test (f)? "&": "?") + v.data, удалить v.data) ,! 1 === v.Кэш && (е = f.replace (Ot, "$ 1"), о = (St.test (е) "&": "?") + "_ =" + кт +++ о), v.url = е + о), v.ifModified && (k.lastModified [е] && T.setRequestHeader ( "If-Modified-С", k.lastModified [е]), k.etag [е] && T.setRequestHeader ( «If-неэквивалентным матч», k.etag [е])), (v.data && v.hasContent &&! 1! == v.contentType || t.contentType) && T.setRequestHeader ( "Content-Type", v.contentType), T.setRequestHeader ( "Accept", v.dataTypes [0] && v.accepts [v.dataTypes [0]]? v.accepts [v.dataTypes [0]] + ( "*"! == v.dataTypes [0]?» , "+ $ t +"; q = 0.01 ":" "): v.accepts [" * "]), v.headers) T.setRequestHeader (i, v.headers [i]); if (v.beforeSend && ( ! 1 === v.beforeSend.call (y, T, v) || h)) вернуть T.abort (); if (u = "abort", b.add (v.complete), T.сделано (v.success), T.fail (v.error), с = _t (Вт, V, T, T)) {если (T.readyState = 1, г && m.trigger ( "ajaxSend", [T, V ]), h) вернуть T; v.async && 0 <v.timeout && (d = C.setTimeout (function () {T.abort ("timeout")}, v.timeout)); try {h =! 1, c .send (a, l)} catch (e) {if (h) throw e; l (-1, e)}} else l (-1, "No Transport"); функция l (e, t, n, r) {var i, o, a, s, u, l = t; h || (h =! 0, d && C.clearTimeout (d), c = void 0, p = r || "", T.readyState = 0 <e? 4: 0, i = 200 <= e && e <300 || 304 === e, n && (s = функция (e, t, n) {var r, i, o, a, s = e .contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), void 0 === r && (r = e.mimeType || t.getResponseHeader ("Content-Type ")); if (r) для (i in s) if (s [i] && s [i] .test (r)) {u.unshift (i); break} if (u [0] в n) o = u [0]; else {for (i in n) {if (! u [0] || e.converters [i + "" + u [0]]) {o = i;break} a || (a = i)} o = o || a} if (o) возвращает o! == u [0] && u.unshift (o), n [o]} (v, T, n) ), s = функция (e, t, n, r) {var i, o, a, s, u, l = {}, c = e.dataTypes.slice (); если (c [1]) для ( a в e.converters) l [a.toLowerCase ()] = e.converters [a]; o = c.shift (); while (o) if (e.responseFields [o] && (n [e.responseFields [ о]] = т) ,! у && г && && e.dataFilter (т = e.dataFilter (т, e.dataType)), и = O, O = c.shift ()), если ( "*" === O) O = u; иначе if ("*"! == u && u! == o) {if (! (a = l [u + "" + o] || l ["*" + o])) для (i в l) if ((s = i.split ("")) [1] === o && (a = l [u + "" + s [0]] || l ["*" + s [0]])) { !? 0 === A A = L [I] :! 0 == л [я] && (O = s [0], c.unshift (с [1]));!}, если перерыв (0! == a) if (a && e ["throws"]) t = a (t); иначе попытайтесь {t = a (t)} catch (e) {return {state: "parsererror", ошибка: a? e: " Нет преобразования из "+ u +" в "+ o}}} return {состояние:"Успех", данные: т}} (V, S, T, I), I (v.ifModified && ((и = T.getResponseHeader ( "Last-Modified")) && (k.lastModified [е] = и ), (и = T.getResponseHeader ( "ETag")) && (k.etag [е] = и)), 204 === е || "голова" === v.type л = "nocontent"?: 304 === е? л = "notmodified" :( л = s.state, о = s.data, я =! (а = s.error))) :( а = л! е && л || (л = "ошибка", е <0 && (е = 0))), T.status = е, T.statusText = (т || л) + "", я? x.resolveWith (у, [о, L, T] ): x.rejectWith (y, [T, l, a]), T.statusCode (w), w = void 0, g && m.trigger (i? "ajaxSuccess": "ajaxError", [T, v, i? о: а]), b.fireWith (у, [T, L]), г && (m.trigger ( "ajaxComplete", [T, V]), - k.active || k.event.trigger (» ajaxStop ")))} return T}, getJSON: function (e, t, n) {return k.get (e, t, n," json ")}, getScript: function (e, t) {return k. получить (е, пустота 0, т,"script")}}), k.each (["get", "post"], function (e, i) {k [i] = function (e, t, n, r) {return m (t) && (r = r || n, n = t, t = void 0), k.ajax (k.extend ({url: e, тип: i, dataType: r, данные: t, успех: n}, k .isPlainObject (e) && e))}}), k._evalUrl = function (e, t) {return k.ajax ({url: e, тип: "GET", dataType: "script", кэш:! 0, async:! 1, global:! 1, конвертеры: {"текстовый скрипт": function () {}}, dataFilter: function (e) {k.globalEval (e, t)}})}, k.fn.extend ({wrapAll: function (e) {var t; вернуть this [0] && (m (e) && (e = e.call (this [0])), t = k (e, this [0] .ownerDocument ) .eq (0) .clone (! 0), this [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; while (e.firstElementChild) e = e .firstElementChild; вернуть e}). append (this)), this}, wrapInner: function (n) {return m (n)? this.each (function (e) {k (this) .wrapInner (n.call ( это, е))}): это.each (function () {var e = k (this), t = e.contents (); t.length? t.wrapAll (n): e.append (n)})}, wrap: function (t) { var n = m (t); вернуть this.each (function (e) {k (this) .wrapAll (n? t.call (this, e): t)})}, развернуть: function (e) {return this.parent (е) .not ( "тело"). каждая (функция () {к (это) .replaceWith (this.childNodes)}), это}}), k.expr.pseudos.hidden = функция (е ) {вернуться! k.expr.pseudos.visible (е)}, k.expr.pseudos.visible = функция (е) {возвращение !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). длина )}, k.ajaxSettings.xhr = function () {try {return new C.XMLHttpRequest} catch (e) {}}; var Ut = {0: 200,1223: 204}, Xt = k.ajaxSettings.xhr ( ); y.cors = !! Xt && "withCredentials" в Xt, y.ajax = Xt = !! Xt, k.ajaxTransport (function (i) {var o, a; if (y.cors || Xt &&! i. crossDomain) return {send: function (e, t) {var n, r = i.xhr (); if (r.open (i.type, i.url, i.async, i.username, i.password) , i.xhrFields) для (n в i.xhrFields) r [n] = i.xhrFields [n]; for (n в i.mimeType && r.overrideMimeType && r.overrideMimeType (i.mimeType), i.crossDomain || e ["X-Requested-With"] || (e ["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader (n, e [n]); o = function (e) {return function () {o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e? r.abort (): "error" === e? "number"! = typeof r.status ? т (0, "ошибка"): т (r.status, r.statusText): т (Ut [r.status] || r.status, r.statusText, "текст" == (r.responseType |! | "text") || "string"! = typeof r.responseText? {binary: r.response}: {text: r.responseText}, r.getAllResponseHeaders ()))}}, r.onload = o () , a = r.onerror = r.ontimeout = o ("ошибка"), void 0! == r.onabort? r.onabort = a: r.onreadystatechange = function () {4 === r.readyState && C.setTimeout (функция () {о && а) (})}, о = о ( "Прервать"), попробуйте {r.send (i.hasContent && i.data || нуль)} поймать (е) {если (о) броска е}}, прервать: функция () {о && о ()}}}), k.ajaxPrefilter (функция (е) {e.crossDomain && (e.contents.script = 1!)}), k.ajaxSetup ({принимает: {script: "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, содержимое: {script: / \ b (?: java | ecma) script \ b /}, преобразователи: {"text script ": function (e) {return k.globalEval (e), e}}}), k.ajaxPrefilter (" script ", function (e) {void 0 === e.cache && (e.cache =! 1 ), e.crossDomain && (e.type = "GET")}), k.ajaxTransport ("script", функция (n) {var r, i; if (n.crossDomain || n.scriptAttrs) return {send: .. функция (е, т) {г = к ( "<скрипт>") Attr (n.scriptAttrs || {}) проп ({кодировка: n.scriptCharset, SRC: n.url}).on («ошибка загрузки», i = function (e) {r.remove (), i = null, e && t («error» === e.type? 404: 200, e.type)}), E.head .appendChild (r [0])}, abort: function () {i && i ()}}}); var Vt, Gt = [], Yt = / (=) \? (? = & | $) | \? \? /; k.ajaxSetup ({jsonp: "обратный вызов", jsonpCallback: function () {var e = Gt.pop () || k.expando + "_" + kt ++; вернуть это [e] =! 0, e }}), k.ajaxPrefilter ("json jsonp", функция (e, t, n) {var r, i, o, a =! 1! == e.jsonp && (Yt.test (e.url)? " url ":" string "== typeof e.data && 0 === (e.contentType ||" "). indexOf (" application / x-www-form-urlencoded ") && Yt.test (e.data) &&" data "); if (a ||" jsonp "=== e.dataTypes [0]) return r = e.jsonpCallback = m (e.jsonpCallback)? e.jsonpCallback (): e.jsonpCallback, a? e [a ] = е [а] .Надеть (Yt, "$ 1" + г) :! 1! == e.jsonp && (e.url + = (St.test (е.url)? "&": "?") + e.jsonp + "=" + r), e.converters ["script json"] = function () {return o || k.error (r + "не был вызван" ), o [0]}, e.dataTypes [0] = "json", i = C [r], C [r] = function () {o = arguments}, n.always (function () {void 0 ? === я к (С) .removeProp (г): С [г] = я, е [г] && (e.jsonpCallback = t.jsonpCallback, Gt.push (г)), о && м (я) && я ( o [0]), o = i = void 0}), "script"}), y.createHTMLDocument = ((Vt = E.implementation.createHTMLDocument (""). body) .innerHTML = "<form> </ form> <form> </ form> ", 2 === Vt.childNodes.length), k.parseHTML = function (e, t, n) {вернуть" строку "! = typeof e? [] :(" логическое значение "== typeof t && (n = t, t =! 1), t || (y.createHTMLDocument? ((r = (t = E.implementation.createHTMLDocument (" ")). createElement (" base ")). HREF = E.location.href, t.head.AppendChild (г)):? Т = Е), а = п && [], (я = D.exec (е)) [t.createElement (я [1])] :( я = мы ([е], t, o), o && o.length && k (o) .remove (), k.merge ([], i.childNodes))); var r, i, o}, k.fn.load = function (e, t, n) {var r, i, o, a = this, s = e.indexOf (""); return-1 <s && (r = mt (e.slice (s)), e = e.slice (0, s)), m (t)? (n = t, t = void 0): t && "object" == typeof t && (i = "POST"), 0 <a.length && k.ajax ({url: e, type : я || "GET", DATATYPE: "HTML", данные:.? т}) Done (функция (е) {о = аргументы, a.html (г к ( "<DIV>") добавить (к.. parseHTML (е)) находим (г):. д.)}) всегда (п && функция (е, т) {a.each (функция () {n.apply (это, о || [e.responseText, т, е ])})}), это}, k.each ([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], функция (е, т) {к.fn [t] = function (e) {вернуть this.on (t, e)}}), k.expr.pseudos.animated = function (t) {вернуть k.grep (k.timers, function (e) { return t === e.elem}). length}, k.offset = {setOffset: function (e, t, n) {var r, i, o, a, s, u, l = k.css (e , "положение"), с = к (е), е = {}; "статические" === л && (e.style.position = "относительно"), с = c.offset (), о = k.css (е, "верхний"), и = k.css (е, "влево"), ( "абсолютный" === л || "фиксированный" === л) && - 1 <(о + и) .indexOf ( "авто")? (а = (г = c.position ()). сверху, я = r.left) :( а = parseFloat (о) || 0, г = parseFloat (и) || 0), м (т) && (т = t.call (е, п, k.extend ({}, с))), нулевая! = t.top && (f.top = t.top-s.top + а), null! = t.left && (f.left = t.left-s.left + i), "using" в t? t.using.call (e, f): c.css (f)}}, k. fn.extend ({offset: function (t) {if (arguments.length) return void 0 === t? this: this.each (function (e) {k.offset.setOffset (this, t,e)}); var e, n, r = this [0]; вернуть r? r.getClientRects (). length? (e = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {top: e. top + n.pageYOffset, слева: e.left + n.pageXOffset}): {top: 0, left: 0}: void 0}, position: function () {if (this [0]) {var e, t , п, г = это [0], I = {верх: 0, слева: 0}, если ( "фиксированные" === k.css (г, "позиция")) т = r.getBoundingClientRect (); остальное {т = this.offset (), п = r.ownerDocument, е = r.offsetParent || n.documentElement, тогда как (е && (е === n.body || е === n.documentElement) && "статические "=== k.css (е," позиция ")) е = e.parentNode;!. е && е == г && 1 === e.nodeType && ((я = к (е) .offset ()) = верхняя часть + к. CSS (! е, "borderTopWidth", 0), i.left + = k.css (! е, "borderLeftWidth", 0))} {возвращение верхней части: t.top-i.top-k.css (г,» marginTop ",! 0), слева: t.left-i.left-k.css (r," marginLeft ",! 0)}}}, offsetParent: function () {вернуть это.map (function () {var e = this.offsetParent; while (e && "static" === k.css (e, "position")) e = e.offsetParent; вернуть e || т.е.})}}), k.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, функция (t, i) {var o = "pageYOffset" === i; k.fn [t] = function (e) {return _ (this, функция (e, t, n) {var r; if (x (e)? r = e: 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? г [г]: е [т]; г r.scrollTo (о r.pageXOffset:? п, о н: r.pageYOffset): е [т] = п}, т, е, arguments.length) }}), k.each ([ "верх", "влево"], функция (е, п) {k.cssHooks [п] = ге (y.pixelPosition, функция (е, т) {если (т) возвращение т = _e (е, п), $ e.test (т) к (е) .position () [N] + "ПВ": т})}), k.each ({высота: "высота", ширина: "ширина"}, функция (а, с) {k.each ({обивка: "внутренний" + а, содержание: s "": "внешний" + а}, функция (г, о) {к. п [о] = функция (е,t) {var n = arguments.length && (r || "логическое"! = typeof e), i = r || (! 0 === e ||! 0 === t? "margin": "border" ); return _ (this, function (e, t, n) {var r; return x (e)? 0 === o.indexOf ("external")? e ["inner" + a]: e.document .documentElement [ "клиент" + а]: 9 === e.nodeType (г = e.documentElement, Math.max (e.body [ "прокрутки" + а], R [ "прокрутки" + а], е .body ["offset" + a], r ["offset" + a], r ["client" + a])): void 0 === n? k.css (e, t, i): k. style (e, t, n, i)}, s, n? e: void 0, n)}})}), k.each ("размытие фокуса, фокусировка в фокусе, изменение размера, прокрутка, щелчок dblclick mousedown mouseup mousemove mouseover выберите отправить keydown нажатие клавиши keyup contextmenu ".split (" "), function (e, n) {k.fn [n] = function (e, t) {return 0 <arguments.length? this.on (n, null, е, т): this.trigger (п)}}), k.fn.extended ({hover: function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}}), k.fn.extend ({bind: function (e, t, n) {return this.on (e, null, t, n)}, unbind: function (e, t) {return this.off (e, null, t)}, делегат: function (e, t, n, r) {return this.on (t, e, n, r)}, undelegate: function (e, t, n) {return 1 === arguments.length? this.off (e, "**"): this.off ( t, e || "**", n)}}), k.proxy = function (e, t) {var n, r, i; if ("строка" == typeof t && (n = e [t]) , t = e, e = n), m (e)) return r = s.call (аргументы, 2), (i = function () {return e.apply (t || this, r.concat (s. звоните (аргументы)))}) справ = e.guid = e.guid || k.guid ++, я}, k.holdReady = функция (е) {е k.readyWait ++.?! k.ready (0)} , k.isArray = Array.isArray, k.parseJSON = JSON.parse, k.nodeName = А, k.isFunction = м, k.isWindow = х, k.camelCase = В, k.type = ш, k.now = Date.now, k.isNumeric = function (e) {var t = k.type (e); return ("число" === t || "строка" === t) &&! isNaN (e-parseFloat (e))}, "function" == typeof define && define.amd && define ("jquery", [], function () {return k}); var Qt = C.jQuery, Jt = C. $ ; return k.noConflict = function (e) {return C. $ === k && (C. $ = Jt), e && C.jQuery === k && (C.jQuery = Qt), k}, e || (C .jQuery = С $ = к), к}).